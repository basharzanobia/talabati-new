//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    forgetpassword(email: string): Observable<void> {
        let url_ = this.baseUrl + "/forgetpassword?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetpassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgetpassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param token (optional) 
     * @param email (optional) 
     * @param newPassword (optional) 
     * @param confirmPassword (optional) 
     * @return Success
     */
    resetpassword(token: string | undefined, email: string | undefined, newPassword: string | undefined, confirmPassword: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/resetpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (token === null || token === undefined)
            throw new Error("The parameter 'token' cannot be null.");
        else
            content_.append("token", token.toString());
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("Email", email.toString());
        if (newPassword === null || newPassword === undefined)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else
            content_.append("NewPassword", newPassword.toString());
        if (confirmPassword === null || confirmPassword === undefined)
            throw new Error("The parameter 'confirmPassword' cannot be null.");
        else
            content_.append("ConfirmPassword", confirmPassword.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetpassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetpassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BuyrequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getrequestbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addrequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updaterequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/buyrequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getallrequests(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }
}

@Injectable()
export class HomeapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    menu(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/homeapi/menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processMenu(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(null as any);
    }

    /**
     * @return Success
     */
    slider(): Observable<Slider[]> {
        let url_ = this.baseUrl + "/api/homeapi/slider";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider[]>;
        }));
    }

    protected processSlider(response: HttpResponseBase): Observable<Slider[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Slider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider[]>(null as any);
    }

    /**
     * @return Success
     */
    brand(): Observable<Brand[]> {
        let url_ = this.baseUrl + "/api/homeapi/brand";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Brand[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Brand[]>;
        }));
    }

    protected processBrand(response: HttpResponseBase): Observable<Brand[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Brand.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Brand[]>(null as any);
    }

    /**
     * @return Success
     */
    featuredproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/featuredproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeaturedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeaturedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processFeaturedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }

    /**
     * @return Success
     */
    purchasedproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/purchasedproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchasedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchasedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processPurchasedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }
}

@Injectable()
export class OrderapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    list(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    trackingbyorderid(orderId: number | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/orderapi/trackingbyorderid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrackingbyorderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrackingbyorderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processTrackingbyorderid(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    single(orderId: number | undefined): Observable<Order> {
        let url_ = this.baseUrl + "/api/orderapi/single?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OrderRequestModel | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Order | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/orderapi/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProductapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: ProductFilterModel | undefined): Observable<ProductResponseModel> {
        let url_ = this.baseUrl + "/api/productapi/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductResponseModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ProductResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductResponseModel>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    single(productId: number | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/productapi/single?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @return Success
     */
    allproducts(): Observable<void> {
        let url_ = this.baseUrl + "/api/productapi/allproducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllproducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllproducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllproducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ServerequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getrequestbyid(id: number | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addrequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updaterequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/serverequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getallrequests(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }
}

@Injectable()
export class UserapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginApiModel | undefined): Observable<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/userapi/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: UserRegisterModel | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/userapi/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }
}

@Injectable()
export class VendorapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    categories(): Observable<VendorCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorCategory[]>;
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<VendorCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorCategory[]>(null as any);
    }

    /**
     * @param catId (optional) 
     * @return Success
     */
    subcategories(catId: number | undefined): Observable<VendorSubCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/subcategories?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorSubCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorSubCategory[]>;
        }));
    }

    protected processSubcategories(response: HttpResponseBase): Observable<VendorSubCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorSubCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorSubCategory[]>(null as any);
    }

    /**
     * @param catId (optional) 
     * @return Success
     */
    vendorsbycatid(catId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbycatid?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbycatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbycatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbycatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * @param subCatId (optional) 
     * @return Success
     */
    vendorsbysubcatid(subCatId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbysubcatid?";
        if (subCatId === null)
            throw new Error("The parameter 'subCatId' cannot be null.");
        else if (subCatId !== undefined)
            url_ += "subCatId=" + encodeURIComponent("" + subCatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbysubcatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbysubcatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbysubcatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    vendorbyid(vendorId: string | undefined): Observable<UserResponseModel> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorbyid?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel>;
        }));
    }

    protected processVendorbyid(response: HttpResponseBase): Observable<UserResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel>(null as any);
    }
}

export class ApplicationRole implements IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.arabicName = _data["arabicName"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["arabicName"] = this.arabicName;
        return data;
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;
}

export class ApplicationUser implements IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    readonly isActiveMarge: boolean;
    notificationToken: string | undefined;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.name = _data["name"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
            this.isActive = _data["isActive"];
            this.isApproved = _data["isApproved"];
            if (Array.isArray(_data["vendorCovers"])) {
                this.vendorCovers = [] as any;
                for (let item of _data["vendorCovers"])
                    this.vendorCovers.push(VendorCover.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
            (<any>this).isActiveMarge = _data["isActiveMarge"];
            this.notificationToken = _data["notificationToken"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        data["isActive"] = this.isActive;
        data["isApproved"] = this.isApproved;
        if (Array.isArray(this.vendorCovers)) {
            data["vendorCovers"] = [];
            for (let item of this.vendorCovers)
                data["vendorCovers"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        data["isActiveMarge"] = this.isActiveMarge;
        data["notificationToken"] = this.notificationToken;
        return data;
    }

    clone(): ApplicationUser {
        const json = this.toJSON();
        let result = new ApplicationUser();
        result.init(json);
        return result;
    }
}

export interface IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    isActiveMarge: boolean;
    notificationToken: string | undefined;
}

export class ApplicationUserRole implements IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;

    constructor(data?: IApplicationUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): ApplicationUserRole {
        const json = this.toJSON();
        let result = new ApplicationUserRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;
}

export class Brand implements IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Brand {
        const json = this.toJSON();
        let result = new Brand();
        result.init(json);
        return result;
    }
}

export interface IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
}

export class BuyMe implements IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IBuyMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BuyMe {
        data = typeof data === 'object' ? data : {};
        let result = new BuyMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): BuyMe {
        const json = this.toJSON();
        let result = new BuyMe();
        result.init(json);
        return result;
    }
}

export interface IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Category implements ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of _data["subCategory"])
                    this.subCategory.push(SubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Category {
        const json = this.toJSON();
        let result = new Category();
        result.init(json);
        return result;
    }
}

export interface ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;
}

export class Color implements IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: IColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.colorCode = _data["colorCode"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Color {
        data = typeof data === 'object' ? data : {};
        let result = new Color();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["colorCode"] = this.colorCode;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Color {
        const json = this.toJSON();
        let result = new Color();
        result.init(json);
        return result;
    }
}

export interface IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class LoginApiModel implements ILoginApiModel {
    email: string | undefined;
    password: string | undefined;

    constructor(data?: ILoginApiModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginApiModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginApiModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): LoginApiModel {
        const json = this.toJSON();
        let result = new LoginApiModel();
        result.init(json);
        return result;
    }
}

export interface ILoginApiModel {
    email: string | undefined;
    password: string | undefined;
}

export class LoginResponseModel implements ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;

    constructor(data?: ILoginResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.token = _data["token"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.id = _data["id"];
            this.tid = _data["tid"];
        }
    }

    static fromJS(data: any): LoginResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["id"] = this.id;
        data["tid"] = this.tid;
        return data;
    }

    clone(): LoginResponseModel {
        const json = this.toJSON();
        let result = new LoginResponseModel();
        result.init(json);
        return result;
    }
}

export interface ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;
}

export class Order implements IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: number;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: number;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    readonly addressMarge: string | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.additionalMobile = _data["additionalMobile"];
            this.pincode = _data["pincode"];
            this.houseNo = _data["houseNo"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.area = _data["area"];
            this.landmark = _data["landmark"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.orderNotes = _data["orderNotes"];
            this.statements = _data["statements"];
            this.paymentMode = _data["paymentMode"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.shippingPincode = _data["shippingPincode"];
            this.shippingAmount = _data["shippingAmount"];
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
            if (Array.isArray(_data["tracking"])) {
                this.tracking = [] as any;
                for (let item of _data["tracking"])
                    this.tracking.push(Tracking.fromJS(item));
            }
            (<any>this).addressMarge = _data["addressMarge"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["additionalMobile"] = this.additionalMobile;
        data["pincode"] = this.pincode;
        data["houseNo"] = this.houseNo;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["area"] = this.area;
        data["landmark"] = this.landmark;
        data["city"] = this.city;
        data["state"] = this.state;
        data["orderNotes"] = this.orderNotes;
        data["statements"] = this.statements;
        data["paymentMode"] = this.paymentMode;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["shippingPincode"] = this.shippingPincode;
        data["shippingAmount"] = this.shippingAmount;
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.tracking)) {
            data["tracking"] = [];
            for (let item of this.tracking)
                data["tracking"].push(item.toJSON());
        }
        data["addressMarge"] = this.addressMarge;
        return data;
    }

    clone(): Order {
        const json = this.toJSON();
        let result = new Order();
        result.init(json);
        return result;
    }
}

export interface IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: number;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: number;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    addressMarge: string | undefined;
}

export class OrderDetail implements IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): OrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): OrderDetail {
        const json = this.toJSON();
        let result = new OrderDetail();
        result.init(json);
        return result;
    }
}

export interface IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class OrderDetailRequest implements IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    varientId: number;

    constructor(data?: IOrderDetailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.varientId = _data["varientId"];
        }
    }

    static fromJS(data: any): OrderDetailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["varientId"] = this.varientId;
        return data;
    }

    clone(): OrderDetailRequest {
        const json = this.toJSON();
        let result = new OrderDetailRequest();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    varientId: number;
}

export class OrderRequestModel implements IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    shippingAmount: number;
    state: string;
    address: string;
    lastName: string;
    middleName: string;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;

    constructor(data?: IOrderRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.area = _data["area"];
            this.city = _data["city"];
            this.houseNo = _data["houseNo"];
            this.paymentMode = _data["paymentMode"];
            this.shippingAmount = _data["shippingAmount"];
            this.state = _data["state"];
            this.address = _data["address"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.orderNotes = _data["orderNotes"];
            this.pincode = _data["pincode"];
            this.shippingPincode = _data["shippingPincode"];
            this.statements = _data["statements"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetailRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["area"] = this.area;
        data["city"] = this.city;
        data["houseNo"] = this.houseNo;
        data["paymentMode"] = this.paymentMode;
        data["shippingAmount"] = this.shippingAmount;
        data["state"] = this.state;
        data["address"] = this.address;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["orderNotes"] = this.orderNotes;
        data["pincode"] = this.pincode;
        data["shippingPincode"] = this.shippingPincode;
        data["statements"] = this.statements;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrderRequestModel {
        const json = this.toJSON();
        let result = new OrderRequestModel();
        result.init(json);
        return result;
    }
}

export interface IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    shippingAmount: number;
    state: string;
    address: string;
    lastName: string;
    middleName: string;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;
}

export enum OrderStatusType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum PaymentModeType {
    _1 = 1,
    _2 = 2,
}

export class Product implements IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number;
    subCategory: SubCategory;
    subSubCategoryId: number;
    subSubCategory: SubSubCategory;
    brandId: number;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.subSubCategoryId = _data["subSubCategoryId"];
            this.subSubCategory = _data["subSubCategory"] ? SubSubCategory.fromJS(_data["subSubCategory"]) : <any>undefined;
            this.brandId = _data["brandId"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.rating = _data["rating"];
            this.mainImagePath = _data["mainImagePath"];
            this.hasVarient = _data["hasVarient"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.isRetunable = _data["isRetunable"];
            this.isCOD = _data["isCOD"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.purchaseCount = _data["purchaseCount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
            if (Array.isArray(_data["productImage"])) {
                this.productImage = [] as any;
                for (let item of _data["productImage"])
                    this.productImage.push(ProductImage.fromJS(item));
            }
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["wishlist"])) {
                this.wishlist = [] as any;
                for (let item of _data["wishlist"])
                    this.wishlist.push(Wishlist.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["subSubCategoryId"] = this.subSubCategoryId;
        data["subSubCategory"] = this.subSubCategory ? this.subSubCategory.toJSON() : <any>undefined;
        data["brandId"] = this.brandId;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["rating"] = this.rating;
        data["mainImagePath"] = this.mainImagePath;
        data["hasVarient"] = this.hasVarient;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["isRetunable"] = this.isRetunable;
        data["isCOD"] = this.isCOD;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["purchaseCount"] = this.purchaseCount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        if (Array.isArray(this.productImage)) {
            data["productImage"] = [];
            for (let item of this.productImage)
                data["productImage"].push(item.toJSON());
        }
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.wishlist)) {
            data["wishlist"] = [];
            for (let item of this.wishlist)
                data["wishlist"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Product {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export interface IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number;
    subCategory: SubCategory;
    subSubCategoryId: number;
    subSubCategory: SubSubCategory;
    brandId: number;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class ProductFilterModel implements IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;

    constructor(data?: IProductFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.subSubCategory = _data["subSubCategory"];
            this.price = _data["price"];
            this.brand = _data["brand"];
            this.size = _data["size"];
            this.color = _data["color"];
            this.sortBy = _data["sortBy"];
            this.take = _data["take"];
            this.totalProducts = _data["totalProducts"];
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.creatorId = _data["creatorId"];
        }
    }

    static fromJS(data: any): ProductFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["subSubCategory"] = this.subSubCategory;
        data["price"] = this.price;
        data["brand"] = this.brand;
        data["size"] = this.size;
        data["color"] = this.color;
        data["sortBy"] = this.sortBy;
        data["take"] = this.take;
        data["totalProducts"] = this.totalProducts;
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["creatorId"] = this.creatorId;
        return data;
    }

    clone(): ProductFilterModel {
        const json = this.toJSON();
        let result = new ProductFilterModel();
        result.init(json);
        return result;
    }
}

export interface IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;
}

export class ProductImage implements IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IProductImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): ProductImage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): ProductImage {
        const json = this.toJSON();
        let result = new ProductImage();
        result.init(json);
        return result;
    }
}

export interface IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class ProductResponseModel implements IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;

    constructor(data?: IProductResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products.push(Product.fromJS(item));
            }
            this.totalProducts = _data["totalProducts"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.totalPages = _data["totalPages"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
        }
    }

    static fromJS(data: any): ProductResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["totalProducts"] = this.totalProducts;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["totalPages"] = this.totalPages;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        return data;
    }

    clone(): ProductResponseModel {
        const json = this.toJSON();
        let result = new ProductResponseModel();
        result.init(json);
        return result;
    }
}

export interface IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;
}

export enum RequestStatusType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class Review implements IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): Review {
        const json = this.toJSON();
        let result = new Review();
        result.init(json);
        return result;
    }
}

export interface IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;
}

export enum ReviewStatusType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ServeMe implements IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IServeMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServeMe {
        data = typeof data === 'object' ? data : {};
        let result = new ServeMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): ServeMe {
        const json = this.toJSON();
        let result = new ServeMe();
        result.init(json);
        return result;
    }
}

export interface IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Size implements ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: ISize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Size {
        data = typeof data === 'object' ? data : {};
        let result = new Size();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Size {
        const json = this.toJSON();
        let result = new Size();
        result.init(json);
        return result;
    }
}

export interface ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class Slider implements ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ISlider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.url = _data["url"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Slider {
        data = typeof data === 'object' ? data : {};
        let result = new Slider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["url"] = this.url;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Slider {
        const json = this.toJSON();
        let result = new Slider();
        result.init(json);
        return result;
    }
}

export interface ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export enum SortByType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class StringBaseResponse implements IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;

    constructor(data?: IStringBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): StringBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): StringBaseResponse {
        const json = this.toJSON();
        let result = new StringBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;
}

export class SubCategory implements ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ISubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subSubCategory"])) {
                this.subSubCategory = [] as any;
                for (let item of _data["subSubCategory"])
                    this.subSubCategory.push(SubSubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subSubCategory)) {
            data["subSubCategory"] = [];
            for (let item of this.subSubCategory)
                data["subSubCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubCategory {
        const json = this.toJSON();
        let result = new SubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;
}

export class SubSubCategory implements ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;

    constructor(data?: ISubSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): SubSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): SubSubCategory {
        const json = this.toJSON();
        let result = new SubSubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;
}

export class Tracking implements ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ITracking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.title = _data["title"];
            this.message = _data["message"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Tracking {
        data = typeof data === 'object' ? data : {};
        let result = new Tracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["message"] = this.message;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Tracking {
        const json = this.toJSON();
        let result = new Tracking();
        result.init(json);
        return result;
    }
}

export interface ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class UserCart implements IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;

    constructor(data?: IUserCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.tempUid = _data["tempUid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.total = _data["total"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCart {
        data = typeof data === 'object' ? data : {};
        let result = new UserCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["tempUid"] = this.tempUid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["total"] = this.total;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserCart {
        const json = this.toJSON();
        let result = new UserCart();
        result.init(json);
        return result;
    }
}

export interface IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;
}

export class UserRegisterModel implements IUserRegisterModel {
    email: string;
    password: string;
    confirmPassword: string;
    returnUrl: string | undefined;

    constructor(data?: IUserRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): UserRegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): UserRegisterModel {
        const json = this.toJSON();
        let result = new UserRegisterModel();
        result.init(json);
        return result;
    }
}

export interface IUserRegisterModel {
    email: string;
    password: string;
    confirmPassword: string;
    returnUrl: string | undefined;
}

export class UserResponseModel implements IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;

    constructor(data?: IUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories.push(VendorSubCategoryResponseModel.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
        }
    }

    static fromJS(data: any): UserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        return data;
    }

    clone(): UserResponseModel {
        const json = this.toJSON();
        let result = new UserResponseModel();
        result.init(json);
        return result;
    }
}

export interface IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
}

export class UserVendorSubCategory implements IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;

    constructor(data?: IUserVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.vendorSubCategoryId = _data["vendorSubCategoryId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.vendorSubCategory = _data["vendorSubCategory"] ? VendorSubCategory.fromJS(_data["vendorSubCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserVendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new UserVendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["vendorSubCategoryId"] = this.vendorSubCategoryId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["vendorSubCategory"] = this.vendorSubCategory ? this.vendorSubCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserVendorSubCategory {
        const json = this.toJSON();
        let result = new UserVendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;
}

export class Varient implements IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number;
    size: Size;
    colorId: number;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IVarient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.sizeId = _data["sizeId"];
            this.size = _data["size"] ? Size.fromJS(_data["size"]) : <any>undefined;
            this.colorId = _data["colorId"];
            this.color = _data["color"] ? Color.fromJS(_data["color"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.mainImagePath = _data["mainImagePath"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varientImage"])) {
                this.varientImage = [] as any;
                for (let item of _data["varientImage"])
                    this.varientImage.push(VarientImage.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Varient {
        data = typeof data === 'object' ? data : {};
        let result = new Varient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["sizeId"] = this.sizeId;
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        data["colorId"] = this.colorId;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["mainImagePath"] = this.mainImagePath;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varientImage)) {
            data["varientImage"] = [];
            for (let item of this.varientImage)
                data["varientImage"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Varient {
        const json = this.toJSON();
        let result = new Varient();
        result.init(json);
        return result;
    }
}

export interface IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number;
    size: Size;
    colorId: number;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class VarientImage implements IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVarientImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VarientImage {
        data = typeof data === 'object' ? data : {};
        let result = new VarientImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VarientImage {
        const json = this.toJSON();
        let result = new VarientImage();
        result.init(json);
        return result;
    }
}

export interface IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class VendorCategory implements IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;

    constructor(data?: IVendorCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["vendorSubCategory"])) {
                this.vendorSubCategory = [] as any;
                for (let item of _data["vendorSubCategory"])
                    this.vendorSubCategory.push(VendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.vendorSubCategory)) {
            data["vendorSubCategory"] = [];
            for (let item of this.vendorSubCategory)
                data["vendorSubCategory"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorCategory {
        const json = this.toJSON();
        let result = new VendorCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;
}

export class VendorCover implements IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;

    constructor(data?: IVendorCover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.applicatioUserId = _data["applicatioUserId"];
            this.applicatioUser = _data["applicatioUser"] ? ApplicationUser.fromJS(_data["applicatioUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorCover {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCover();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["applicatioUserId"] = this.applicatioUserId;
        data["applicatioUser"] = this.applicatioUser ? this.applicatioUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): VendorCover {
        const json = this.toJSON();
        let result = new VendorCover();
        result.init(json);
        return result;
    }
}

export interface IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;
}

export class VendorSubCategory implements IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;

    constructor(data?: IVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.vendorCategory = _data["vendorCategory"] ? VendorCategory.fromJS(_data["vendorCategory"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["vendorCategory"] = this.vendorCategory ? this.vendorCategory.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorSubCategory {
        const json = this.toJSON();
        let result = new VendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
}

export class VendorSubCategoryResponseModel implements IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;

    constructor(data?: IVendorSubCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): VendorSubCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        return data;
    }

    clone(): VendorSubCategoryResponseModel {
        const json = this.toJSON();
        let result = new VendorSubCategoryResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;
}

export class Wishlist implements IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Wishlist {
        data = typeof data === 'object' ? data : {};
        let result = new Wishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Wishlist {
        const json = this.toJSON();
        let result = new Wishlist();
        result.init(json);
        return result;
    }
}

export interface IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}