//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AddressapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createaddress(body: UserAddress | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/createaddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processCreateaddress(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateaddress(body: UserAddress | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/updateaddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processUpdateaddress(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteaddress(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/addressapi/deleteaddress?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteaddress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getrequestsbyuserid(userId: string | undefined): Observable<UserAddress[]> {
        let url_ = this.baseUrl + "/api/addressapi/getrequestsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress[]>;
        }));
    }

    protected processGetrequestsbyuserid(response: HttpResponseBase): Observable<UserAddress[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserAddress.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress[]>(null as any);
    }
}

@Injectable()
export class BuyrequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getrequestbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addrequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updaterequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/buyrequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getallrequests(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }
}

@Injectable()
export class ChatapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param senderId (optional) 
     * @param recieverId (optional) 
     * @return Success
     */
    getchat(senderId: string | undefined, recieverId: string | undefined): Observable<ChatLog[]> {
        let url_ = this.baseUrl + "/api/chatapi/getchat?";
        if (senderId === null)
            throw new Error("The parameter 'senderId' cannot be null.");
        else if (senderId !== undefined)
            url_ += "senderId=" + encodeURIComponent("" + senderId) + "&";
        if (recieverId === null)
            throw new Error("The parameter 'recieverId' cannot be null.");
        else if (recieverId !== undefined)
            url_ += "recieverId=" + encodeURIComponent("" + recieverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetchat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetchat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLog[]>;
        }));
    }

    protected processGetchat(response: HttpResponseBase): Observable<ChatLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLog[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getmessagesbyuserid(userId: string | undefined): Observable<ChatLog[]> {
        let url_ = this.baseUrl + "/api/chatapi/getmessagesbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmessagesbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmessagesbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLog[]>;
        }));
    }

    protected processGetmessagesbyuserid(response: HttpResponseBase): Observable<ChatLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLog[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createmessage(body: ChatLog | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/chatapi/createmessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatemessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatemessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatemessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class CouponapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param promoCode (optional) 
     * @param uid (optional) 
     * @return Success
     */
    validatepromocode(promoCode: string | undefined, uid: string | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/validatepromocode?";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "promoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatepromocode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatepromocode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processValidatepromocode(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }

    /**
     * @return Success
     */
    getallcoupons(): Observable<Coupon[]> {
        let url_ = this.baseUrl + "/api/couponapi/getallcoupons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallcoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallcoupons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon[]>;
        }));
    }

    protected processGetallcoupons(response: HttpResponseBase): Observable<Coupon[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Coupon.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Coupon[]>(null as any);
    }

    /**
     * @param couponCode (optional) 
     * @return Success
     */
    getbycouponcode(couponCode: string | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/getbycouponcode?";
        if (couponCode === null)
            throw new Error("The parameter 'couponCode' cannot be null.");
        else if (couponCode !== undefined)
            url_ += "couponCode=" + encodeURIComponent("" + couponCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbycouponcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbycouponcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processGetbycouponcode(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }
}

@Injectable()
export class DynamicpagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * @param slug (optional) 
     * @return Success
     */
    getbyslug(slug: string | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbyslug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyslug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyslug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbyslug(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * @param title (optional) 
     * @return Success
     */
    getbytitle(title: string | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbytitle?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbytitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbytitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbytitle(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * @return Success
     */
    getpages(): Observable<DynamicPageModel[]> {
        let url_ = this.baseUrl + "/api/dynamicpages/getpages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetpages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetpages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel[]>;
        }));
    }

    protected processGetpages(response: HttpResponseBase): Observable<DynamicPageModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DynamicPageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createpage(body: DynamicPageModel | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/dynamicpages/createpage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatepage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatepage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatepage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class EwalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deposite(body: EWallet | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ewallet/deposite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeposite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeposite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeposite(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    withdraw(body: EWallet | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ewallet/withdraw";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWithdraw(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWithdraw(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processWithdraw(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    totalbyuserid(userId: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/ewallet/totalbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTotalbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTotalbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTotalbyuserid(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class HomeapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    menu(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/homeapi/menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processMenu(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(null as any);
    }

    /**
     * @return Success
     */
    slider(): Observable<Slider[]> {
        let url_ = this.baseUrl + "/api/homeapi/slider";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider[]>;
        }));
    }

    protected processSlider(response: HttpResponseBase): Observable<Slider[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Slider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider[]>(null as any);
    }

    /**
     * @return Success
     */
    brand(): Observable<Brand[]> {
        let url_ = this.baseUrl + "/api/homeapi/brand";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Brand[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Brand[]>;
        }));
    }

    protected processBrand(response: HttpResponseBase): Observable<Brand[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Brand.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Brand[]>(null as any);
    }

    /**
     * @return Success
     */
    featuredproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/featuredproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeaturedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeaturedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processFeaturedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }

    /**
     * @return Success
     */
    purchasedproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/purchasedproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchasedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchasedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processPurchasedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }
}

@Injectable()
export class NotificationapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getordernotificationsbyuserid(userId: string | undefined): Observable<NotificationLogListBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/getordernotificationsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetordernotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetordernotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLogListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLogListBaseResponse>;
        }));
    }

    protected processGetordernotificationsbyuserid(response: HttpResponseBase): Observable<NotificationLogListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationLogListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLogListBaseResponse>(null as any);
    }

    /**
     * @param receiverId (optional) 
     * @return Success
     */
    getmessagesnotificationsbyuserid(receiverId: string | undefined): Observable<ChatLogListBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/getmessagesnotificationsbyuserid?";
        if (receiverId === null)
            throw new Error("The parameter 'receiverId' cannot be null.");
        else if (receiverId !== undefined)
            url_ += "receiverId=" + encodeURIComponent("" + receiverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmessagesnotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmessagesnotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLogListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLogListBaseResponse>;
        }));
    }

    protected processGetmessagesnotificationsbyuserid(response: HttpResponseBase): Observable<ChatLogListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatLogListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLogListBaseResponse>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @return Success
     */
    openordernotification(notificationId: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/openordernotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenordernotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenordernotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processOpenordernotification(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @return Success
     */
    openmessagenotification(notificationId: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/openmessagenotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenmessagenotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenmessagenotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processOpenmessagenotification(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }
}

@Injectable()
export class OrderapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    list(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    trackingbyorderid(orderId: number | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/orderapi/trackingbyorderid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrackingbyorderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrackingbyorderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processTrackingbyorderid(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    single(orderId: number | undefined): Observable<Order> {
        let url_ = this.baseUrl + "/api/orderapi/single?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OrderRequestModel | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Order | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/orderapi/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PopularquestionsapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getrequestbyid(id: number | undefined): Observable<PopularQuestions> {
        let url_ = this.baseUrl + "/api/popularquestionsapi/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularQuestions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularQuestions>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<PopularQuestions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PopularQuestions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopularQuestions>(null as any);
    }

    /**
     * @param category (optional) 
     * @return Success
     */
    listbycategory(category: UserType | undefined): Observable<PopularQuestions[]> {
        let url_ = this.baseUrl + "/api/popularquestionsapi/listbycategory?";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbycategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbycategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularQuestions[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularQuestions[]>;
        }));
    }

    protected processListbycategory(response: HttpResponseBase): Observable<PopularQuestions[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PopularQuestions.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopularQuestions[]>(null as any);
    }
}

@Injectable()
export class ProductapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: ProductFilterModel | undefined): Observable<ProductResponseModel> {
        let url_ = this.baseUrl + "/api/productapi/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductResponseModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ProductResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductResponseModel>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    single(productId: number | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/productapi/single?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @return Success
     */
    allproducts(): Observable<void> {
        let url_ = this.baseUrl + "/api/productapi/allproducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllproducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllproducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllproducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getproductbyname(name: string | undefined): Observable<ProductModel[]> {
        let url_ = this.baseUrl + "/api/productapi/getproductbyname?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductbyname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductbyname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel[]>;
        }));
    }

    protected processGetproductbyname(response: HttpResponseBase): Observable<ProductModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getproductwithdiscount(): Observable<ProductModel[]> {
        let url_ = this.baseUrl + "/api/productapi/getproductwithdiscount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductwithdiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductwithdiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel[]>;
        }));
    }

    protected processGetproductwithdiscount(response: HttpResponseBase): Observable<ProductModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModel[]>(null as any);
    }
}

@Injectable()
export class ReviewproductapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: Review | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getreviewsbyproductid(productId: number | undefined): Observable<ReviewListBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/getreviewsbyproductid?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetreviewsbyproductid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetreviewsbyproductid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewListBaseResponse>;
        }));
    }

    protected processGetreviewsbyproductid(response: HttpResponseBase): Observable<ReviewListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewListBaseResponse>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getratingofproduct(productId: number | undefined): Observable<DoubleBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/getratingofproduct?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetratingofproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetratingofproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoubleBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoubleBaseResponse>;
        }));
    }

    protected processGetratingofproduct(response: HttpResponseBase): Observable<DoubleBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoubleBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoubleBaseResponse>(null as any);
    }
}

@Injectable()
export class ReviewuserapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: UserReview | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewuserapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getreviewsbyuserid(userId: string | undefined): Observable<ReviewUserResponse[]> {
        let url_ = this.baseUrl + "/api/reviewuserapi/getreviewsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetreviewsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetreviewsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewUserResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewUserResponse[]>;
        }));
    }

    protected processGetreviewsbyuserid(response: HttpResponseBase): Observable<ReviewUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReviewUserResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewUserResponse[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getratingofuser(userId: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/reviewuserapi/getratingofuser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetratingofuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetratingofuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetratingofuser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ServerequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getrequestbyid(id: number | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addrequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updaterequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/serverequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getallrequests(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * @param creatorId (optional) 
     * @return Success
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }
}

@Injectable()
export class UserapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginApiModel | undefined): Observable<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/userapi/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: UserRegisterModel | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/userapi/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploaduserphoto(userId: string | undefined, file: FileParameter | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/userapi/uploaduserphoto?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaduserphoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaduserphoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processUploaduserphoto(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgetpassword(email: string | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/userapi/forgetpassword?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetpassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processForgetpassword(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetpassword(body: ResetPasswordViewModel | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/userapi/resetpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetpassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processResetpassword(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }
}

@Injectable()
export class UserlocationapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatedriverlocation(body: UserLocation | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userlocationapi/updatedriverlocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatedriverlocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatedriverlocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdatedriverlocation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class VendorapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    categories(): Observable<VendorCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorCategory[]>;
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<VendorCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorCategory[]>(null as any);
    }

    /**
     * @param catId (optional) 
     * @return Success
     */
    subcategories(catId: number | undefined): Observable<VendorSubCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/subcategories?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorSubCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorSubCategory[]>;
        }));
    }

    protected processSubcategories(response: HttpResponseBase): Observable<VendorSubCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorSubCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorSubCategory[]>(null as any);
    }

    /**
     * @param catId (optional) 
     * @return Success
     */
    vendorsbycatid(catId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbycatid?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbycatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbycatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbycatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * @param subCatId (optional) 
     * @return Success
     */
    vendorsbysubcatid(subCatId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbysubcatid?";
        if (subCatId === null)
            throw new Error("The parameter 'subCatId' cannot be null.");
        else if (subCatId !== undefined)
            url_ += "subCatId=" + encodeURIComponent("" + subCatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbysubcatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbysubcatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbysubcatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    vendorbyid(vendorId: string | undefined): Observable<UserResponseModel> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorbyid?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel>;
        }));
    }

    protected processVendorbyid(response: HttpResponseBase): Observable<UserResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel>(null as any);
    }
}

@Injectable()
export class VendorwishlistapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getwishlist(userId: string | undefined): Observable<VendorWishListResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/getwishlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorWishListResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorWishListResponseModel[]>;
        }));
    }

    protected processGetwishlist(response: HttpResponseBase): Observable<VendorWishListResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorWishListResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorWishListResponseModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createwish(body: VendorWishlist | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/createwish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param wishId (optional) 
     * @return Success
     */
    deletewish(wishId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/deletewish?";
        if (wishId === null)
            throw new Error("The parameter 'wishId' cannot be null.");
        else if (wishId !== undefined)
            url_ += "wishId=" + encodeURIComponent("" + wishId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class WishlistapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getwishlist(userId: string | undefined): Observable<WishListModel[]> {
        let url_ = this.baseUrl + "/api/wishlistapi/getwishlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WishListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WishListModel[]>;
        }));
    }

    protected processGetwishlist(response: HttpResponseBase): Observable<WishListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WishListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WishListModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createwish(body: Wishlist | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/createwish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param wishId (optional) 
     * @return Success
     */
    deletewish(wishId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/deletewish?";
        if (wishId === null)
            throw new Error("The parameter 'wishId' cannot be null.");
        else if (wishId !== undefined)
            url_ += "wishId=" + encodeURIComponent("" + wishId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

export enum AccessControl {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum AddressType {
    _0 = 0,
    _1 = 1,
}

export class ApplicationRole implements IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;
    rolePermissions: RolePermissions[] | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.arabicName = _data["arabicName"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions.push(RolePermissions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["arabicName"] = this.arabicName;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;
    rolePermissions: RolePermissions[] | undefined;
}

export class ApplicationUser implements IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    rating: number;
    userWhish: VendorWishlist[] | undefined;
    vendorWish: VendorWishlist[] | undefined;
    userReviews: UserReview[] | undefined;
    ratersReviews: UserReview[] | undefined;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    coupons: Coupon[] | undefined;
    banners: Banner[] | undefined;
    readonly isActiveMarge: boolean;
    notificationToken: string | undefined;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.name = _data["name"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
            this.isActive = _data["isActive"];
            this.isApproved = _data["isApproved"];
            this.rating = _data["rating"];
            if (Array.isArray(_data["userWhish"])) {
                this.userWhish = [] as any;
                for (let item of _data["userWhish"])
                    this.userWhish.push(VendorWishlist.fromJS(item));
            }
            if (Array.isArray(_data["vendorWish"])) {
                this.vendorWish = [] as any;
                for (let item of _data["vendorWish"])
                    this.vendorWish.push(VendorWishlist.fromJS(item));
            }
            if (Array.isArray(_data["userReviews"])) {
                this.userReviews = [] as any;
                for (let item of _data["userReviews"])
                    this.userReviews.push(UserReview.fromJS(item));
            }
            if (Array.isArray(_data["ratersReviews"])) {
                this.ratersReviews = [] as any;
                for (let item of _data["ratersReviews"])
                    this.ratersReviews.push(UserReview.fromJS(item));
            }
            if (Array.isArray(_data["vendorCovers"])) {
                this.vendorCovers = [] as any;
                for (let item of _data["vendorCovers"])
                    this.vendorCovers.push(VendorCover.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons.push(Coupon.fromJS(item));
            }
            if (Array.isArray(_data["banners"])) {
                this.banners = [] as any;
                for (let item of _data["banners"])
                    this.banners.push(Banner.fromJS(item));
            }
            (<any>this).isActiveMarge = _data["isActiveMarge"];
            this.notificationToken = _data["notificationToken"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        data["isActive"] = this.isActive;
        data["isApproved"] = this.isApproved;
        data["rating"] = this.rating;
        if (Array.isArray(this.userWhish)) {
            data["userWhish"] = [];
            for (let item of this.userWhish)
                data["userWhish"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorWish)) {
            data["vendorWish"] = [];
            for (let item of this.vendorWish)
                data["vendorWish"].push(item.toJSON());
        }
        if (Array.isArray(this.userReviews)) {
            data["userReviews"] = [];
            for (let item of this.userReviews)
                data["userReviews"].push(item.toJSON());
        }
        if (Array.isArray(this.ratersReviews)) {
            data["ratersReviews"] = [];
            for (let item of this.ratersReviews)
                data["ratersReviews"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorCovers)) {
            data["vendorCovers"] = [];
            for (let item of this.vendorCovers)
                data["vendorCovers"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item.toJSON());
        }
        if (Array.isArray(this.banners)) {
            data["banners"] = [];
            for (let item of this.banners)
                data["banners"].push(item.toJSON());
        }
        data["isActiveMarge"] = this.isActiveMarge;
        data["notificationToken"] = this.notificationToken;
        return data;
    }

    clone(): ApplicationUser {
        const json = this.toJSON();
        let result = new ApplicationUser();
        result.init(json);
        return result;
    }
}

export interface IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    rating: number;
    userWhish: VendorWishlist[] | undefined;
    vendorWish: VendorWishlist[] | undefined;
    userReviews: UserReview[] | undefined;
    ratersReviews: UserReview[] | undefined;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    coupons: Coupon[] | undefined;
    banners: Banner[] | undefined;
    isActiveMarge: boolean;
    notificationToken: string | undefined;
}

export class ApplicationUserRole implements IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;

    constructor(data?: IApplicationUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): ApplicationUserRole {
        const json = this.toJSON();
        let result = new ApplicationUserRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;
}

export class Banner implements IBanner {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userId: string | undefined;
    user: ApplicationUser;

    constructor(data?: IBanner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Banner {
        data = typeof data === 'object' ? data : {};
        let result = new Banner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): Banner {
        const json = this.toJSON();
        let result = new Banner();
        result.init(json);
        return result;
    }
}

export interface IBanner {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userId: string | undefined;
    user: ApplicationUser;
}

export class BooleanBaseResponse implements IBooleanBaseResponse {
    success: boolean;
    response: string | undefined;
    data: boolean;
    modelKey: string | undefined;

    constructor(data?: IBooleanBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): BooleanBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): BooleanBaseResponse {
        const json = this.toJSON();
        let result = new BooleanBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IBooleanBaseResponse {
    success: boolean;
    response: string | undefined;
    data: boolean;
    modelKey: string | undefined;
}

export class Brand implements IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Brand {
        const json = this.toJSON();
        let result = new Brand();
        result.init(json);
        return result;
    }
}

export interface IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
}

export class BuyMe implements IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IBuyMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BuyMe {
        data = typeof data === 'object' ? data : {};
        let result = new BuyMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): BuyMe {
        const json = this.toJSON();
        let result = new BuyMe();
        result.init(json);
        return result;
    }
}

export interface IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Category implements ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of _data["subCategory"])
                    this.subCategory.push(SubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Category {
        const json = this.toJSON();
        let result = new Category();
        result.init(json);
        return result;
    }
}

export interface ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;
}

export class ChatLog implements IChatLog {
    id: number;
    tid: number;
    senderId: string | undefined;
    sender: ApplicationUser;
    recieverId: string | undefined;
    reciever: ApplicationUser;
    text: string;
    sendingDate: moment.Moment;
    recievingDate: moment.Moment;
    read: boolean;
    notificationJson: string | undefined;
    responseJson: string | undefined;
    token: string | undefined;

    constructor(data?: IChatLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.senderId = _data["senderId"];
            this.sender = _data["sender"] ? ApplicationUser.fromJS(_data["sender"]) : <any>undefined;
            this.recieverId = _data["recieverId"];
            this.reciever = _data["reciever"] ? ApplicationUser.fromJS(_data["reciever"]) : <any>undefined;
            this.text = _data["text"];
            this.sendingDate = _data["sendingDate"] ? moment(_data["sendingDate"].toString()) : <any>undefined;
            this.recievingDate = _data["recievingDate"] ? moment(_data["recievingDate"].toString()) : <any>undefined;
            this.read = _data["read"];
            this.notificationJson = _data["notificationJson"];
            this.responseJson = _data["responseJson"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ChatLog {
        data = typeof data === 'object' ? data : {};
        let result = new ChatLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["senderId"] = this.senderId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["recieverId"] = this.recieverId;
        data["reciever"] = this.reciever ? this.reciever.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["sendingDate"] = this.sendingDate ? this.sendingDate.toISOString() : <any>undefined;
        data["recievingDate"] = this.recievingDate ? this.recievingDate.toISOString() : <any>undefined;
        data["read"] = this.read;
        data["notificationJson"] = this.notificationJson;
        data["responseJson"] = this.responseJson;
        data["token"] = this.token;
        return data;
    }

    clone(): ChatLog {
        const json = this.toJSON();
        let result = new ChatLog();
        result.init(json);
        return result;
    }
}

export interface IChatLog {
    id: number;
    tid: number;
    senderId: string | undefined;
    sender: ApplicationUser;
    recieverId: string | undefined;
    reciever: ApplicationUser;
    text: string;
    sendingDate: moment.Moment;
    recievingDate: moment.Moment;
    read: boolean;
    notificationJson: string | undefined;
    responseJson: string | undefined;
    token: string | undefined;
}

export class ChatLogListBaseResponse implements IChatLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: ChatLog[] | undefined;
    modelKey: string | undefined;

    constructor(data?: IChatLogListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ChatLog.fromJS(item));
            }
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): ChatLogListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatLogListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): ChatLogListBaseResponse {
        const json = this.toJSON();
        let result = new ChatLogListBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IChatLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: ChatLog[] | undefined;
    modelKey: string | undefined;
}

export class Color implements IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: IColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.colorCode = _data["colorCode"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Color {
        data = typeof data === 'object' ? data : {};
        let result = new Color();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["colorCode"] = this.colorCode;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Color {
        const json = this.toJSON();
        let result = new Color();
        result.init(json);
        return result;
    }
}

export interface IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class Coupon implements ICoupon {
    id: number;
    tid: number;
    couponCode: string;
    discountType: string;
    discountValue: number;
    maxDiscountAmount: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    createdDate: moment.Moment;
    status: boolean;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.couponCode = _data["couponCode"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.maxDiscountAmount = _data["maxDiscountAmount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["couponCode"] = this.couponCode;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["maxDiscountAmount"] = this.maxDiscountAmount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Coupon {
        const json = this.toJSON();
        let result = new Coupon();
        result.init(json);
        return result;
    }
}

export interface ICoupon {
    id: number;
    tid: number;
    couponCode: string;
    discountType: string;
    discountValue: number;
    maxDiscountAmount: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    createdDate: moment.Moment;
    status: boolean;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class CouponBaseResponse implements ICouponBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Coupon;
    modelKey: string | undefined;

    constructor(data?: ICouponBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"] ? Coupon.fromJS(_data["data"]) : <any>undefined;
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): CouponBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CouponBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): CouponBaseResponse {
        const json = this.toJSON();
        let result = new CouponBaseResponse();
        result.init(json);
        return result;
    }
}

export interface ICouponBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Coupon;
    modelKey: string | undefined;
}

export class DoubleBaseResponse implements IDoubleBaseResponse {
    success: boolean;
    response: string | undefined;
    data: number;
    modelKey: string | undefined;

    constructor(data?: IDoubleBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): DoubleBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): DoubleBaseResponse {
        const json = this.toJSON();
        let result = new DoubleBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IDoubleBaseResponse {
    success: boolean;
    response: string | undefined;
    data: number;
    modelKey: string | undefined;
}

export enum DriverTaskStatusType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DynamicPageModel implements IDynamicPageModel {
    id: number;
    title: string;
    content: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment | undefined;
    updatedBy: string | undefined;
    publishedDate: moment.Moment | undefined;
    publishedBy: string | undefined;
    slug: string | undefined;
    isPublished: boolean;

    constructor(data?: IDynamicPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.publishedDate = _data["publishedDate"] ? moment(_data["publishedDate"].toString()) : <any>undefined;
            this.publishedBy = _data["publishedBy"];
            this.slug = _data["slug"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): DynamicPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["publishedDate"] = this.publishedDate ? this.publishedDate.toISOString() : <any>undefined;
        data["publishedBy"] = this.publishedBy;
        data["slug"] = this.slug;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): DynamicPageModel {
        const json = this.toJSON();
        let result = new DynamicPageModel();
        result.init(json);
        return result;
    }
}

export interface IDynamicPageModel {
    id: number;
    title: string;
    content: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment | undefined;
    updatedBy: string | undefined;
    publishedDate: moment.Moment | undefined;
    publishedBy: string | undefined;
    slug: string | undefined;
    isPublished: boolean;
}

export class EWallet implements IEWallet {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    transactionType: TransactionType;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;

    constructor(data?: IEWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.transactionType = _data["transactionType"];
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): EWallet {
        data = typeof data === 'object' ? data : {};
        let result = new EWallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["transactionType"] = this.transactionType;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }

    clone(): EWallet {
        const json = this.toJSON();
        let result = new EWallet();
        result.init(json);
        return result;
    }
}

export interface IEWallet {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    transactionType: TransactionType;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
}

export enum Gender {
    _0 = 0,
    _1 = 1,
}

export class LoginApiModel implements ILoginApiModel {
    email: string | undefined;
    password: string | undefined;

    constructor(data?: ILoginApiModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginApiModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginApiModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): LoginApiModel {
        const json = this.toJSON();
        let result = new LoginApiModel();
        result.init(json);
        return result;
    }
}

export interface ILoginApiModel {
    email: string | undefined;
    password: string | undefined;
}

export class LoginResponseModel implements ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;

    constructor(data?: ILoginResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.token = _data["token"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.id = _data["id"];
            this.tid = _data["tid"];
        }
    }

    static fromJS(data: any): LoginResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["id"] = this.id;
        data["tid"] = this.tid;
        return data;
    }

    clone(): LoginResponseModel {
        const json = this.toJSON();
        let result = new LoginResponseModel();
        result.init(json);
        return result;
    }
}

export interface ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;
}

export class NotificationLog implements INotificationLog {
    id: number;
    token: string;
    userId: string | undefined;
    orderId: number | undefined;
    notificationJson: string;
    responseJson: string | undefined;
    isOpended: boolean;
    createdDate: moment.Moment;

    constructor(data?: INotificationLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.orderId = _data["orderId"];
            this.notificationJson = _data["notificationJson"];
            this.responseJson = _data["responseJson"];
            this.isOpended = _data["isOpended"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationLog {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["orderId"] = this.orderId;
        data["notificationJson"] = this.notificationJson;
        data["responseJson"] = this.responseJson;
        data["isOpended"] = this.isOpended;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): NotificationLog {
        const json = this.toJSON();
        let result = new NotificationLog();
        result.init(json);
        return result;
    }
}

export interface INotificationLog {
    id: number;
    token: string;
    userId: string | undefined;
    orderId: number | undefined;
    notificationJson: string;
    responseJson: string | undefined;
    isOpended: boolean;
    createdDate: moment.Moment;
}

export class NotificationLogListBaseResponse implements INotificationLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: NotificationLog[] | undefined;
    modelKey: string | undefined;

    constructor(data?: INotificationLogListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NotificationLog.fromJS(item));
            }
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): NotificationLogListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationLogListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): NotificationLogListBaseResponse {
        const json = this.toJSON();
        let result = new NotificationLogListBaseResponse();
        result.init(json);
        return result;
    }
}

export interface INotificationLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: NotificationLog[] | undefined;
    modelKey: string | undefined;
}

export class Order implements IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: Gender;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: AddressType;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    readonly addressMarge: string | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.additionalMobile = _data["additionalMobile"];
            this.pincode = _data["pincode"];
            this.houseNo = _data["houseNo"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.area = _data["area"];
            this.landmark = _data["landmark"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.orderNotes = _data["orderNotes"];
            this.statements = _data["statements"];
            this.paymentMode = _data["paymentMode"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.shippingPincode = _data["shippingPincode"];
            this.shippingAmount = _data["shippingAmount"];
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.driverTaskStatus = _data["driverTaskStatus"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
            if (Array.isArray(_data["tracking"])) {
                this.tracking = [] as any;
                for (let item of _data["tracking"])
                    this.tracking.push(Tracking.fromJS(item));
            }
            (<any>this).addressMarge = _data["addressMarge"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["additionalMobile"] = this.additionalMobile;
        data["pincode"] = this.pincode;
        data["houseNo"] = this.houseNo;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["area"] = this.area;
        data["landmark"] = this.landmark;
        data["city"] = this.city;
        data["state"] = this.state;
        data["orderNotes"] = this.orderNotes;
        data["statements"] = this.statements;
        data["paymentMode"] = this.paymentMode;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["shippingPincode"] = this.shippingPincode;
        data["shippingAmount"] = this.shippingAmount;
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["driverTaskStatus"] = this.driverTaskStatus;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.tracking)) {
            data["tracking"] = [];
            for (let item of this.tracking)
                data["tracking"].push(item.toJSON());
        }
        data["addressMarge"] = this.addressMarge;
        return data;
    }

    clone(): Order {
        const json = this.toJSON();
        let result = new Order();
        result.init(json);
        return result;
    }
}

export interface IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: Gender;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: AddressType;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    addressMarge: string | undefined;
}

export class OrderDetail implements IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorId: string | undefined;
    vendor: ApplicationUser;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.subOrderId = _data["subOrderId"];
            this.subOrder = _data["subOrder"] ? SubOrder.fromJS(_data["subOrder"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["subOrderId"] = this.subOrderId;
        data["subOrder"] = this.subOrder ? this.subOrder.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        return data;
    }

    clone(): OrderDetail {
        const json = this.toJSON();
        let result = new OrderDetail();
        result.init(json);
        return result;
    }
}

export interface IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorId: string | undefined;
    vendor: ApplicationUser;
}

export class OrderDetailRequest implements IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    varientId: number;
    vendorId: string;

    constructor(data?: IOrderDetailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.varientId = _data["varientId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): OrderDetailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["varientId"] = this.varientId;
        data["vendorId"] = this.vendorId;
        return data;
    }

    clone(): OrderDetailRequest {
        const json = this.toJSON();
        let result = new OrderDetailRequest();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    varientId: number;
    vendorId: string;
}

export class OrderRequestModel implements IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    shippingAmount: number;
    state: string;
    address: string;
    lastName: string;
    middleName: string;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    createdBy: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;

    constructor(data?: IOrderRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.area = _data["area"];
            this.city = _data["city"];
            this.houseNo = _data["houseNo"];
            this.paymentMode = _data["paymentMode"];
            this.shippingAmount = _data["shippingAmount"];
            this.state = _data["state"];
            this.address = _data["address"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.orderNotes = _data["orderNotes"];
            this.pincode = _data["pincode"];
            this.shippingPincode = _data["shippingPincode"];
            this.statements = _data["statements"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetailRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["area"] = this.area;
        data["city"] = this.city;
        data["houseNo"] = this.houseNo;
        data["paymentMode"] = this.paymentMode;
        data["shippingAmount"] = this.shippingAmount;
        data["state"] = this.state;
        data["address"] = this.address;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["orderNotes"] = this.orderNotes;
        data["pincode"] = this.pincode;
        data["shippingPincode"] = this.shippingPincode;
        data["statements"] = this.statements;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrderRequestModel {
        const json = this.toJSON();
        let result = new OrderRequestModel();
        result.init(json);
        return result;
    }
}

export interface IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    shippingAmount: number;
    state: string;
    address: string;
    lastName: string;
    middleName: string;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    createdBy: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;
}

export enum OrderStatusType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum PaymentModeType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Permissions implements IPermissions {
    id: number;
    tid: number;
    accessControl: AccessControl;
    entity: string | undefined;

    constructor(data?: IPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.accessControl = _data["accessControl"];
            this.entity = _data["entity"];
        }
    }

    static fromJS(data: any): Permissions {
        data = typeof data === 'object' ? data : {};
        let result = new Permissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["accessControl"] = this.accessControl;
        data["entity"] = this.entity;
        return data;
    }

    clone(): Permissions {
        const json = this.toJSON();
        let result = new Permissions();
        result.init(json);
        return result;
    }
}

export interface IPermissions {
    id: number;
    tid: number;
    accessControl: AccessControl;
    entity: string | undefined;
}

export class PopularQuestions implements IPopularQuestions {
    id: number;
    tid: number;
    question: string | undefined;
    answer: string | undefined;
    category: UserType;
    createdDate: string | undefined;
    createdBy: string | undefined;

    constructor(data?: IPopularQuestions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.question = _data["question"];
            this.answer = _data["answer"];
            this.category = _data["category"];
            this.createdDate = _data["createdDate"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): PopularQuestions {
        data = typeof data === 'object' ? data : {};
        let result = new PopularQuestions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["question"] = this.question;
        data["answer"] = this.answer;
        data["category"] = this.category;
        data["createdDate"] = this.createdDate;
        data["createdBy"] = this.createdBy;
        return data;
    }

    clone(): PopularQuestions {
        const json = this.toJSON();
        let result = new PopularQuestions();
        result.init(json);
        return result;
    }
}

export interface IPopularQuestions {
    id: number;
    tid: number;
    question: string | undefined;
    answer: string | undefined;
    category: UserType;
    createdDate: string | undefined;
    createdBy: string | undefined;
}

export class Product implements IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number | undefined;
    subCategory: SubCategory;
    subSubCategoryId: number | undefined;
    subSubCategory: SubSubCategory;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.subSubCategoryId = _data["subSubCategoryId"];
            this.subSubCategory = _data["subSubCategory"] ? SubSubCategory.fromJS(_data["subSubCategory"]) : <any>undefined;
            this.brandId = _data["brandId"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.rating = _data["rating"];
            this.mainImagePath = _data["mainImagePath"];
            this.hasVarient = _data["hasVarient"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.isRetunable = _data["isRetunable"];
            this.isCOD = _data["isCOD"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.purchaseCount = _data["purchaseCount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
            if (Array.isArray(_data["productImage"])) {
                this.productImage = [] as any;
                for (let item of _data["productImage"])
                    this.productImage.push(ProductImage.fromJS(item));
            }
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["wishlist"])) {
                this.wishlist = [] as any;
                for (let item of _data["wishlist"])
                    this.wishlist.push(Wishlist.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["subSubCategoryId"] = this.subSubCategoryId;
        data["subSubCategory"] = this.subSubCategory ? this.subSubCategory.toJSON() : <any>undefined;
        data["brandId"] = this.brandId;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["rating"] = this.rating;
        data["mainImagePath"] = this.mainImagePath;
        data["hasVarient"] = this.hasVarient;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["isRetunable"] = this.isRetunable;
        data["isCOD"] = this.isCOD;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["purchaseCount"] = this.purchaseCount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        if (Array.isArray(this.productImage)) {
            data["productImage"] = [];
            for (let item of this.productImage)
                data["productImage"].push(item.toJSON());
        }
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.wishlist)) {
            data["wishlist"] = [];
            for (let item of this.wishlist)
                data["wishlist"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Product {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export interface IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number | undefined;
    subCategory: SubCategory;
    subSubCategoryId: number | undefined;
    subSubCategory: SubSubCategory;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class ProductFilterModel implements IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;

    constructor(data?: IProductFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.subSubCategory = _data["subSubCategory"];
            this.price = _data["price"];
            this.brand = _data["brand"];
            this.size = _data["size"];
            this.color = _data["color"];
            this.sortBy = _data["sortBy"];
            this.take = _data["take"];
            this.totalProducts = _data["totalProducts"];
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.creatorId = _data["creatorId"];
        }
    }

    static fromJS(data: any): ProductFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["subSubCategory"] = this.subSubCategory;
        data["price"] = this.price;
        data["brand"] = this.brand;
        data["size"] = this.size;
        data["color"] = this.color;
        data["sortBy"] = this.sortBy;
        data["take"] = this.take;
        data["totalProducts"] = this.totalProducts;
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["creatorId"] = this.creatorId;
        return data;
    }

    clone(): ProductFilterModel {
        const json = this.toJSON();
        let result = new ProductFilterModel();
        result.init(json);
        return result;
    }
}

export interface IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;
}

export class ProductImage implements IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IProductImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): ProductImage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): ProductImage {
        const json = this.toJSON();
        let result = new ProductImage();
        result.init(json);
        return result;
    }
}

export interface IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class ProductModel implements IProductModel {
    id: number;
    tid: number;
    name: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    categoryId: number;
    subCategoryId: number | undefined;
    subSubCategoryId: number | undefined;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.categoryId = _data["categoryId"];
            this.subCategoryId = _data["subCategoryId"];
            this.subSubCategoryId = _data["subSubCategoryId"];
            this.brandId = _data["brandId"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.rating = _data["rating"];
            this.mainImagePath = _data["mainImagePath"];
            this.hasVarient = _data["hasVarient"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.isRetunable = _data["isRetunable"];
            this.isCOD = _data["isCOD"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.purchaseCount = _data["purchaseCount"];
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["subSubCategoryId"] = this.subSubCategoryId;
        data["brandId"] = this.brandId;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["rating"] = this.rating;
        data["mainImagePath"] = this.mainImagePath;
        data["hasVarient"] = this.hasVarient;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["isRetunable"] = this.isRetunable;
        data["isCOD"] = this.isCOD;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["purchaseCount"] = this.purchaseCount;
        return data;
    }

    clone(): ProductModel {
        const json = this.toJSON();
        let result = new ProductModel();
        result.init(json);
        return result;
    }
}

export interface IProductModel {
    id: number;
    tid: number;
    name: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    categoryId: number;
    subCategoryId: number | undefined;
    subSubCategoryId: number | undefined;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
}

export class ProductResponseModel implements IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;

    constructor(data?: IProductResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products.push(Product.fromJS(item));
            }
            this.totalProducts = _data["totalProducts"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.totalPages = _data["totalPages"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
        }
    }

    static fromJS(data: any): ProductResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["totalProducts"] = this.totalProducts;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["totalPages"] = this.totalPages;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        return data;
    }

    clone(): ProductResponseModel {
        const json = this.toJSON();
        let result = new ProductResponseModel();
        result.init(json);
        return result;
    }
}

export interface IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;
}

export enum RequestStatusType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    token: string;
    email: string;
    newPassword: string;
    confirmPassword: string;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): ResetPasswordViewModel {
        const json = this.toJSON();
        let result = new ResetPasswordViewModel();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordViewModel {
    token: string;
    email: string;
    newPassword: string;
    confirmPassword: string;
}

export class Review implements IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): Review {
        const json = this.toJSON();
        let result = new Review();
        result.init(json);
        return result;
    }
}

export interface IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;
}

export class ReviewListBaseResponse implements IReviewListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Review[] | undefined;
    modelKey: string | undefined;

    constructor(data?: IReviewListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Review.fromJS(item));
            }
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): ReviewListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): ReviewListBaseResponse {
        const json = this.toJSON();
        let result = new ReviewListBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IReviewListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Review[] | undefined;
    modelKey: string | undefined;
}

export enum ReviewStatusType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ReviewUserResponse implements IReviewUserResponse {
    id: number;
    tid: number;
    userId: string | undefined;
    raterId: string | undefined;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IReviewUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.raterId = _data["raterId"];
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): ReviewUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["raterId"] = this.raterId;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): ReviewUserResponse {
        const json = this.toJSON();
        let result = new ReviewUserResponse();
        result.init(json);
        return result;
    }
}

export interface IReviewUserResponse {
    id: number;
    tid: number;
    userId: string | undefined;
    raterId: string | undefined;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class RolePermissions implements IRolePermissions {
    id: number;
    roleId: string | undefined;
    permissionsId: number;
    role: ApplicationRole;
    permission: Permissions;

    constructor(data?: IRolePermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionsId = _data["permissionsId"];
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
            this.permission = _data["permission"] ? Permissions.fromJS(_data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RolePermissions {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionsId"] = this.permissionsId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data;
    }

    clone(): RolePermissions {
        const json = this.toJSON();
        let result = new RolePermissions();
        result.init(json);
        return result;
    }
}

export interface IRolePermissions {
    id: number;
    roleId: string | undefined;
    permissionsId: number;
    role: ApplicationRole;
    permission: Permissions;
}

export class ServeMe implements IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IServeMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServeMe {
        data = typeof data === 'object' ? data : {};
        let result = new ServeMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): ServeMe {
        const json = this.toJSON();
        let result = new ServeMe();
        result.init(json);
        return result;
    }
}

export interface IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Size implements ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: ISize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Size {
        data = typeof data === 'object' ? data : {};
        let result = new Size();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Size {
        const json = this.toJSON();
        let result = new Size();
        result.init(json);
        return result;
    }
}

export interface ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class Slider implements ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ISlider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.url = _data["url"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Slider {
        data = typeof data === 'object' ? data : {};
        let result = new Slider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["url"] = this.url;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Slider {
        const json = this.toJSON();
        let result = new Slider();
        result.init(json);
        return result;
    }
}

export interface ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export enum SortByType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class StringBaseResponse implements IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;

    constructor(data?: IStringBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): StringBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): StringBaseResponse {
        const json = this.toJSON();
        let result = new StringBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;
}

export class SubCategory implements ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ISubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subSubCategory"])) {
                this.subSubCategory = [] as any;
                for (let item of _data["subSubCategory"])
                    this.subSubCategory.push(SubSubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subSubCategory)) {
            data["subSubCategory"] = [];
            for (let item of this.subSubCategory)
                data["subSubCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubCategory {
        const json = this.toJSON();
        let result = new SubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;
}

export class SubOrder implements ISubOrder {
    id: number;
    tid: number;
    orderId: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;

    constructor(data?: ISubOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.driverTaskStatus = _data["driverTaskStatus"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
            if (Array.isArray(_data["tracking"])) {
                this.tracking = [] as any;
                for (let item of _data["tracking"])
                    this.tracking.push(Tracking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SubOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["driverTaskStatus"] = this.driverTaskStatus;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.tracking)) {
            data["tracking"] = [];
            for (let item of this.tracking)
                data["tracking"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubOrder {
        const json = this.toJSON();
        let result = new SubOrder();
        result.init(json);
        return result;
    }
}

export interface ISubOrder {
    id: number;
    tid: number;
    orderId: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
}

export class SubSubCategory implements ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;

    constructor(data?: ISubSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): SubSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): SubSubCategory {
        const json = this.toJSON();
        let result = new SubSubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;
}

export class Tracking implements ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ITracking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.subOrderId = _data["subOrderId"];
            this.subOrder = _data["subOrder"] ? SubOrder.fromJS(_data["subOrder"]) : <any>undefined;
            this.title = _data["title"];
            this.message = _data["message"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Tracking {
        data = typeof data === 'object' ? data : {};
        let result = new Tracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["subOrderId"] = this.subOrderId;
        data["subOrder"] = this.subOrder ? this.subOrder.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["message"] = this.message;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Tracking {
        const json = this.toJSON();
        let result = new Tracking();
        result.init(json);
        return result;
    }
}

export interface ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export enum TransactionType {
    _1 = 1,
    __1 = -1,
}

export class UserAddress implements IUserAddress {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    address: string;
    area: string | undefined;
    city: string | undefined;
    houseNo: string | undefined;
    status: boolean;
    latitude: number;
    longitude: number;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.address = _data["address"];
            this.area = _data["area"];
            this.city = _data["city"];
            this.houseNo = _data["houseNo"];
            this.status = _data["status"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["area"] = this.area;
        data["city"] = this.city;
        data["houseNo"] = this.houseNo;
        data["status"] = this.status;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): UserAddress {
        const json = this.toJSON();
        let result = new UserAddress();
        result.init(json);
        return result;
    }
}

export interface IUserAddress {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    address: string;
    area: string | undefined;
    city: string | undefined;
    houseNo: string | undefined;
    status: boolean;
    latitude: number;
    longitude: number;
}

export class UserCart implements IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;

    constructor(data?: IUserCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.tempUid = _data["tempUid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.total = _data["total"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCart {
        data = typeof data === 'object' ? data : {};
        let result = new UserCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["tempUid"] = this.tempUid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["total"] = this.total;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserCart {
        const json = this.toJSON();
        let result = new UserCart();
        result.init(json);
        return result;
    }
}

export interface IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;
}

export class UserLocation implements IUserLocation {
    latitude: number;
    longitude: number;
    userId: string | undefined;

    constructor(data?: IUserLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserLocation {
        data = typeof data === 'object' ? data : {};
        let result = new UserLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserLocation {
        const json = this.toJSON();
        let result = new UserLocation();
        result.init(json);
        return result;
    }
}

export interface IUserLocation {
    latitude: number;
    longitude: number;
    userId: string | undefined;
}

export class UserRegisterModel implements IUserRegisterModel {
    name: string;
    middleName: string;
    lastName: string;
    nickName: string;
    gender: Gender;
    address: string;
    addressType: AddressType;
    mobile: string;
    additionalMobile: string;
    email: string;
    password: string;
    confirmPassword: string;
    statements: boolean;
    returnUrl: string | undefined;

    constructor(data?: IUserRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.mobile = _data["mobile"];
            this.additionalMobile = _data["additionalMobile"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.statements = _data["statements"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): UserRegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["mobile"] = this.mobile;
        data["additionalMobile"] = this.additionalMobile;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["statements"] = this.statements;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): UserRegisterModel {
        const json = this.toJSON();
        let result = new UserRegisterModel();
        result.init(json);
        return result;
    }
}

export interface IUserRegisterModel {
    name: string;
    middleName: string;
    lastName: string;
    nickName: string;
    gender: Gender;
    address: string;
    addressType: AddressType;
    mobile: string;
    additionalMobile: string;
    email: string;
    password: string;
    confirmPassword: string;
    statements: boolean;
    returnUrl: string | undefined;
}

export class UserResponseModel implements IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    vendorCovers: VendorCoversResponseModel[] | undefined;

    constructor(data?: IUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories.push(VendorSubCategoryResponseModel.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
            if (Array.isArray(_data["vendorCovers"])) {
                this.vendorCovers = [] as any;
                for (let item of _data["vendorCovers"])
                    this.vendorCovers.push(VendorCoversResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        if (Array.isArray(this.vendorCovers)) {
            data["vendorCovers"] = [];
            for (let item of this.vendorCovers)
                data["vendorCovers"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserResponseModel {
        const json = this.toJSON();
        let result = new UserResponseModel();
        result.init(json);
        return result;
    }
}

export interface IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    vendorCovers: VendorCoversResponseModel[] | undefined;
}

export class UserReview implements IUserReview {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    raterId: string | undefined;
    rater: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IUserReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.raterId = _data["raterId"];
            this.rater = _data["rater"] ? ApplicationUser.fromJS(_data["rater"]) : <any>undefined;
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): UserReview {
        data = typeof data === 'object' ? data : {};
        let result = new UserReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["raterId"] = this.raterId;
        data["rater"] = this.rater ? this.rater.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): UserReview {
        const json = this.toJSON();
        let result = new UserReview();
        result.init(json);
        return result;
    }
}

export interface IUserReview {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    raterId: string | undefined;
    rater: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;
}

export enum UserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class UserVendorSubCategory implements IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;

    constructor(data?: IUserVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.vendorSubCategoryId = _data["vendorSubCategoryId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.vendorSubCategory = _data["vendorSubCategory"] ? VendorSubCategory.fromJS(_data["vendorSubCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserVendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new UserVendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["vendorSubCategoryId"] = this.vendorSubCategoryId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["vendorSubCategory"] = this.vendorSubCategory ? this.vendorSubCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserVendorSubCategory {
        const json = this.toJSON();
        let result = new UserVendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;
}

export class Varient implements IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number;
    size: Size;
    colorId: number;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IVarient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.sizeId = _data["sizeId"];
            this.size = _data["size"] ? Size.fromJS(_data["size"]) : <any>undefined;
            this.colorId = _data["colorId"];
            this.color = _data["color"] ? Color.fromJS(_data["color"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.mainImagePath = _data["mainImagePath"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varientImage"])) {
                this.varientImage = [] as any;
                for (let item of _data["varientImage"])
                    this.varientImage.push(VarientImage.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Varient {
        data = typeof data === 'object' ? data : {};
        let result = new Varient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["sizeId"] = this.sizeId;
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        data["colorId"] = this.colorId;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["mainImagePath"] = this.mainImagePath;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varientImage)) {
            data["varientImage"] = [];
            for (let item of this.varientImage)
                data["varientImage"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Varient {
        const json = this.toJSON();
        let result = new Varient();
        result.init(json);
        return result;
    }
}

export interface IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number;
    size: Size;
    colorId: number;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class VarientImage implements IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVarientImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VarientImage {
        data = typeof data === 'object' ? data : {};
        let result = new VarientImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VarientImage {
        const json = this.toJSON();
        let result = new VarientImage();
        result.init(json);
        return result;
    }
}

export interface IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class VendorCategory implements IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;

    constructor(data?: IVendorCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["vendorSubCategory"])) {
                this.vendorSubCategory = [] as any;
                for (let item of _data["vendorSubCategory"])
                    this.vendorSubCategory.push(VendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.vendorSubCategory)) {
            data["vendorSubCategory"] = [];
            for (let item of this.vendorSubCategory)
                data["vendorSubCategory"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorCategory {
        const json = this.toJSON();
        let result = new VendorCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;
}

export class VendorCover implements IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;

    constructor(data?: IVendorCover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.applicatioUserId = _data["applicatioUserId"];
            this.applicatioUser = _data["applicatioUser"] ? ApplicationUser.fromJS(_data["applicatioUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorCover {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCover();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["applicatioUserId"] = this.applicatioUserId;
        data["applicatioUser"] = this.applicatioUser ? this.applicatioUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): VendorCover {
        const json = this.toJSON();
        let result = new VendorCover();
        result.init(json);
        return result;
    }
}

export interface IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;
}

export class VendorCoversResponseModel implements IVendorCoversResponseModel {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicationUserId: string | undefined;

    constructor(data?: IVendorCoversResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.applicationUserId = _data["applicationUserId"];
        }
    }

    static fromJS(data: any): VendorCoversResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCoversResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["applicationUserId"] = this.applicationUserId;
        return data;
    }

    clone(): VendorCoversResponseModel {
        const json = this.toJSON();
        let result = new VendorCoversResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorCoversResponseModel {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicationUserId: string | undefined;
}

export class VendorSubCategory implements IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;

    constructor(data?: IVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.vendorCategory = _data["vendorCategory"] ? VendorCategory.fromJS(_data["vendorCategory"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["vendorCategory"] = this.vendorCategory ? this.vendorCategory.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorSubCategory {
        const json = this.toJSON();
        let result = new VendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
}

export class VendorSubCategoryResponseModel implements IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;

    constructor(data?: IVendorSubCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): VendorSubCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        return data;
    }

    clone(): VendorSubCategoryResponseModel {
        const json = this.toJSON();
        let result = new VendorSubCategoryResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;
}

export class VendorWishlist implements IVendorWishlist {
    id: number;
    tid: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVendorWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VendorWishlist {
        data = typeof data === 'object' ? data : {};
        let result = new VendorWishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VendorWishlist {
        const json = this.toJSON();
        let result = new VendorWishlist();
        result.init(json);
        return result;
    }
}

export interface IVendorWishlist {
    id: number;
    tid: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class VendorWishListResponseModel implements IVendorWishListResponseModel {
    id: number;
    vendorId: string | undefined;
    userId: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVendorWishListResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorId = _data["vendorId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VendorWishListResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorWishListResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorId"] = this.vendorId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VendorWishListResponseModel {
        const json = this.toJSON();
        let result = new VendorWishListResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorWishListResponseModel {
    id: number;
    vendorId: string | undefined;
    userId: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class Wishlist implements IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Wishlist {
        data = typeof data === 'object' ? data : {};
        let result = new Wishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Wishlist {
        const json = this.toJSON();
        let result = new Wishlist();
        result.init(json);
        return result;
    }
}

export interface IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class WishListModel implements IWishListModel {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IWishListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): WishListModel {
        data = typeof data === 'object' ? data : {};
        let result = new WishListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): WishListModel {
        const json = this.toJSON();
        let result = new WishListModel();
        result.init(json);
        return result;
    }
}

export interface IWishListModel {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}