//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AddressapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get user address of a specific id.
     * @param id (optional) id of user address
     * @return Returns the UserAddress
     */
    getbyid(id: number | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * Create new address for the logged in user.
     * @param body (optional) UserAddress object
     * @return Returns the newly created UserAddress
     */
    createaddress(body: UserAddress | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/createaddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processCreateaddress(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * Update user address for the logged in user.
     * @param body (optional) UserAddress object
     * @return Returns the updated UserAddress
     */
    updateaddress(body: UserAddress | undefined): Observable<UserAddress> {
        let url_ = this.baseUrl + "/api/addressapi/updateaddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress>;
        }));
    }

    protected processUpdateaddress(response: HttpResponseBase): Observable<UserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress>(null as any);
    }

    /**
     * Delete specific address of the logged in user.
     * @param id (optional) id of user address
     * @return Returns true
     */
    deleteaddress(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/addressapi/deleteaddress?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteaddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteaddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteaddress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get all addresses for a specific user.
     * @param userId (optional) id of user
     * @return List of user Addresses
     */
    getrequestsbyuserid(userId: string | undefined): Observable<UserAddress[]> {
        let url_ = this.baseUrl + "/api/addressapi/getrequestsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddress[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddress[]>;
        }));
    }

    protected processGetrequestsbyuserid(response: HttpResponseBase): Observable<UserAddress[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserAddress.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAddress[]>(null as any);
    }
}

@Injectable()
export class BuyrequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get all Buy Me requests assigned to the logged in driver.
     * @return List of Buy me requests
     */
    getallbydriverid(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getallbydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallbydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallbydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetallbydriverid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * Get Buy me request of a specific id.
     * @param id (optional) id of Buy Me request
     * @return Buy Me object
     */
    getrequestbyid(id: number | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * Get all Buy Me requests of status pending assigned to the logged in driver.
     * @return List of Buy me objects
     */
    getbuymependingsbydriverid(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getbuymependingsbydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbuymependingsbydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbuymependingsbydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetbuymependingsbydriverid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * Get all Buy Me requests of status Delivered/UnDelivered assigned to the logged in driver.
     * @return List of Buy me objects
     */
    getbuymedonebydriverid(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getbuymedonebydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbuymedonebydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbuymedonebydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetbuymedonebydriverid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * Create new Buy Me request for the logged in user and send notification to admins.
     * @param body (optional) Buy Me object
     * @return the newly created Buy Me object
     */
    addrequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * Update Buy Me request.
     * @param body (optional) Buy Me object
     * @return the updated Buy Me object
     */
    updaterequest(body: BuyMe | undefined): Observable<BuyMe> {
        let url_ = this.baseUrl + "/api/buyrequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<BuyMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuyMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe>(null as any);
    }

    /**
     * Delete specific Buy Me Request of of specific id.
     * @param id (optional) id of Buy Me Object
     * @return true if deleting is successful
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/buyrequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get all Buy Me requests.
     * @return List of Buy me objects
     */
    getallrequests(): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }

    /**
     * Get all Buy Me requests created by a specific user.
     * @param creatorId (optional) id of user
     * @return List of Buy me objects
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<BuyMe[]> {
        let url_ = this.baseUrl + "/api/buyrequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<BuyMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BuyMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuyMe[]>(null as any);
    }
}

@Injectable()
export class ChatapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Chats Archive between two users.
     * @param senderId (optional) id of sender
     * @param recieverId (optional) id of reciever
     * @return List of Chat log objects
     */
    getchat(senderId: string | undefined, recieverId: string | undefined): Observable<ChatLog[]> {
        let url_ = this.baseUrl + "/api/chatapi/getchat?";
        if (senderId === null)
            throw new Error("The parameter 'senderId' cannot be null.");
        else if (senderId !== undefined)
            url_ += "senderId=" + encodeURIComponent("" + senderId) + "&";
        if (recieverId === null)
            throw new Error("The parameter 'recieverId' cannot be null.");
        else if (recieverId !== undefined)
            url_ += "recieverId=" + encodeURIComponent("" + recieverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetchat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetchat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLog[]>;
        }));
    }

    protected processGetchat(response: HttpResponseBase): Observable<ChatLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLog[]>(null as any);
    }

    /**
     * Get all Messages created by a specific user.
     * @param userId (optional) id of user
     * @return List of Chat log objects
     */
    getmessagesbyuserid(userId: string | undefined): Observable<ChatLog[]> {
        let url_ = this.baseUrl + "/api/chatapi/getmessagesbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmessagesbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmessagesbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLog[]>;
        }));
    }

    protected processGetmessagesbyuserid(response: HttpResponseBase): Observable<ChatLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLog[]>(null as any);
    }

    /**
     * Get Latest Chat ocurred between specific user and others.
     * @param userId (optional) id of user
     * @return List of chat log objects
     */
    getlastmessages(userId: string | undefined): Observable<ChatLog[]> {
        let url_ = this.baseUrl + "/api/chatapi/getlastmessages?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlastmessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlastmessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLog[]>;
        }));
    }

    protected processGetlastmessages(response: HttpResponseBase): Observable<ChatLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLog[]>(null as any);
    }

    /**
     * Send a message from a user to another and notifies reciever about the new message.
     * @param body (optional) chat log object
     * @return true if successful
     */
    createmessage(body: ChatLog | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/chatapi/createmessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatemessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatemessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatemessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class CouponapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * checks if a coupon is valid to a specific user.
     * @param promoCode (optional) code of coupon
     * @param uid (optional) user id
     * @return BaseResponse object of the coupon and its validity status( boolean value ) to the user
     */
    validatepromocode(promoCode: string | undefined, uid: string | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/validatepromocode?";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "promoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatepromocode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatepromocode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processValidatepromocode(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }

    /**
     * Get all Coupons.
     * @return list of coupon objects
     */
    getallcoupons(): Observable<Coupon[]> {
        let url_ = this.baseUrl + "/api/couponapi/getallcoupons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallcoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallcoupons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon[]>;
        }));
    }

    protected processGetallcoupons(response: HttpResponseBase): Observable<Coupon[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Coupon.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Coupon[]>(null as any);
    }

    /**
     * Get Coupon by its code.
     * @param couponCode (optional) code of coupon
     * @return BaseResponse object of the coupon and success/fail status
     */
    getbycouponcode(couponCode: string | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/getbycouponcode?";
        if (couponCode === null)
            throw new Error("The parameter 'couponCode' cannot be null.");
        else if (couponCode !== undefined)
            url_ += "couponCode=" + encodeURIComponent("" + couponCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbycouponcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbycouponcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processGetbycouponcode(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }

    /**
     * Get Coupon of specific id.
     * @param id (optional) coupon id
     * @return BaseResponse object of the coupon and success/fail status
     */
    getbyid(id: number | undefined): Observable<CouponBaseResponse> {
        let url_ = this.baseUrl + "/api/couponapi/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponBaseResponse>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CouponBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponBaseResponse>(null as any);
    }
}

@Injectable()
export class DynamicpagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Page of a specific id.
     * @param id (optional) Page id
     * @return return DynamicPageModel object
     */
    getbyid(id: number | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * Get Page of a specific slug.
     * @param slug (optional) Page slug
     * @return return DynamicPageModel object
     */
    getbyslug(slug: string | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbyslug?";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyslug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyslug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbyslug(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * Get Page of a specific Title.
     * @param title (optional) Page title
     * @return return DynamicPageModel object
     */
    getbytitle(title: string | undefined): Observable<DynamicPageModel> {
        let url_ = this.baseUrl + "/api/dynamicpages/getbytitle?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbytitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbytitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel>;
        }));
    }

    protected processGetbytitle(response: HttpResponseBase): Observable<DynamicPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel>(null as any);
    }

    /**
     * Get All dynamic Pages.
     * @return return lis of DynamicPageModel objects
     */
    getpages(): Observable<DynamicPageModel[]> {
        let url_ = this.baseUrl + "/api/dynamicpages/getpages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetpages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetpages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPageModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPageModel[]>;
        }));
    }

    protected processGetpages(response: HttpResponseBase): Observable<DynamicPageModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DynamicPageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageModel[]>(null as any);
    }
}

@Injectable()
export class EwalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add amount of money to logged in user's wallet.
     * @param body (optional) ewallet object to be added
     * @return return true if successfully created
     */
    deposite(body: EWallet | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ewallet/deposite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeposite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeposite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeposite(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Withdraw amount of money from logged in user's wallet.
     * @param body (optional) ewallet object to be added
     * @return return true if successfully created
     */
    withdraw(body: EWallet | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ewallet/withdraw";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWithdraw(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWithdraw(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processWithdraw(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get Total of money in specific user wallet.
     * @param userId (optional) user id
     * @return return float number repesents total
     */
    totalbyuserid(userId: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/ewallet/totalbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTotalbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTotalbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTotalbyuserid(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Add money to some user ewallet by another user 'usually the driver', not valid until accountant approves.
     * @param body (optional) ewallet to be added
     * @return object created
     */
    promisetoadd(body: EWalletPromise | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ewallet/promisetoadd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromisetoadd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromisetoadd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromisetoadd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HomeapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Home Menu items.
     * @return List of Category Objects
     */
    menu(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/homeapi/menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processMenu(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(null as any);
    }

    /**
     * Get Sliders of Home Page.
     * @return return list of Slider objects
     */
    slider(): Observable<Slider[]> {
        let url_ = this.baseUrl + "/api/homeapi/slider";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider[]>;
        }));
    }

    protected processSlider(response: HttpResponseBase): Observable<Slider[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Slider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider[]>(null as any);
    }

    /**
     * Get first four Brands to dispaly in Home Page.
     * @return return list of Brand objects
     */
    brand(): Observable<Brand[]> {
        let url_ = this.baseUrl + "/api/homeapi/brand";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Brand[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Brand[]>;
        }));
    }

    protected processBrand(response: HttpResponseBase): Observable<Brand[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Brand.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Brand[]>(null as any);
    }

    /**
     * Get 8 featured products to be dispalyed in home page.
     * @return return list of product objects
     */
    featuredproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/featuredproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeaturedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeaturedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processFeaturedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }

    /**
     * Get 8 top purchased products.
     * @return return list of product objects
     */
    purchasedproduct(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/homeapi/purchasedproduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchasedproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchasedproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processPurchasedproduct(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }
}

@Injectable()
export class NotificationapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * mark notification as read by its suborder id.
     * @param id (optional) notification id
     * @return Success
     */
    opennotificationbysuborderid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/notificationapi/opennotificationbysuborderid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpennotificationbysuborderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpennotificationbysuborderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOpennotificationbysuborderid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get unread Orders' Notifications that belongs to a specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getorderpendingbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getorderpendingbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetorderpendingbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetorderpendingbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetorderpendingbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get All orders' notifications that belongs to specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getordernotificationsbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getordernotificationsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetordernotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetordernotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetordernotificationsbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get unread Serve Me Requests' Notifications that belongs to a specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getservemependingbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getservemependingbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetservemependingbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetservemependingbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetservemependingbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get All Serve Ne requests' notifications that belongs to specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getservemenotificationsbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getservemenotificationsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetservemenotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetservemenotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetservemenotificationsbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get unread Buy Me Requests' Notifications that belongs to a specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getbuymependingbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getbuymependingbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbuymependingbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbuymependingbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetbuymependingbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get All Buy Ne requests' notifications that belongs to specific driver.
     * @param userId (optional) driver id
     * @return return list of notificationLog objects
     */
    getbuymenotificationsbyuserid(userId: string | undefined): Observable<NotificationLog[]> {
        let url_ = this.baseUrl + "/api/notificationapi/getbuymenotificationsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbuymenotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbuymenotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationLog[]>;
        }));
    }

    protected processGetbuymenotificationsbyuserid(response: HttpResponseBase): Observable<NotificationLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationLog[]>(null as any);
    }

    /**
     * Get New Messages' Notifications that belongs to a specific user.
     * @param receiverId (optional) user id of recipient
     * @return return BaseResponse object of ChatLog objects
     */
    getmessagesnotificationsbyuserid(receiverId: string | undefined): Observable<ChatLogListBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/getmessagesnotificationsbyuserid?";
        if (receiverId === null)
            throw new Error("The parameter 'receiverId' cannot be null.");
        else if (receiverId !== undefined)
            url_ += "receiverId=" + encodeURIComponent("" + receiverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmessagesnotificationsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmessagesnotificationsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatLogListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatLogListBaseResponse>;
        }));
    }

    protected processGetmessagesnotificationsbyuserid(response: HttpResponseBase): Observable<ChatLogListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatLogListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatLogListBaseResponse>(null as any);
    }

    /**
     * Get Page of a specific Title.
     * @param notificationId (optional) Page title
     * @return return DynamicPageModel object
     */
    openordernotification(notificationId: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/openordernotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenordernotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenordernotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processOpenordernotification(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * mark notification as read by its id.
     * @param notificationId (optional) notification Id
     * @return return BaseResponse object of boolean value
     */
    openmessagenotification(notificationId: number | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/notificationapi/openmessagenotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenmessagenotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenmessagenotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processOpenmessagenotification(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }
}

@Injectable()
export class OrderapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get List of All Orders.
     * @return return list of Order
     */
    list(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * Get Orders of specific user.
     * @param creatorId (optional) user id
     * @return return list of Order
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orderapi/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order[]>(null as any);
    }

    /**
     * Get Tracking of specific order.
     * @param orderId (optional) order id
     * @return return list of Tracking
     */
    trackingbyorderid(orderId: number | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/orderapi/trackingbyorderid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrackingbyorderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrackingbyorderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processTrackingbyorderid(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * Get order of specific id.
     * @param orderId (optional) order id
     * @return return Order object
     */
    single(orderId: number | undefined): Observable<Order> {
        let url_ = this.baseUrl + "/api/orderapi/single?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(null as any);
    }

    /**
     * Create un order and sends notification to vendor.
     * @param body (optional) orderFilterModel object
     * @return return order id if successful , otherwise it returns -1
     */
    create(body: OrderRequestModel | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Update un order.
     * @param body (optional) orderFilterModel object
     * @return return updated order id
     */
    update(body: Order | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/orderapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Delete un order of specific id.
     * @param id (optional) order id
     * @return return BaseResponse object of boolean value
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/orderapi/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PaymentcompanyapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get all Payment Companies.
     * @return list of PaymentCompany objects
     */
    getallcompanies(): Observable<PaymentCompany[]> {
        let url_ = this.baseUrl + "/api/paymentcompanyapi/getallcompanies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallcompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallcompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCompany[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCompany[]>;
        }));
    }

    protected processGetallcompanies(response: HttpResponseBase): Observable<PaymentCompany[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentCompany.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentCompany[]>(null as any);
    }
}

@Injectable()
export class PaymenttransactionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add Financial information about payment transaction of order.
     * @param body (optional) 
     * @return true if successfully added
     */
    create(body: PaymentTransactionLog | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/paymenttransaction/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class PopularquestionsapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get popular question of specific id.
     * @param id (optional) popular question id
     * @return return PopularQuestions object
     */
    getrequestbyid(id: number | undefined): Observable<PopularQuestions> {
        let url_ = this.baseUrl + "/api/popularquestionsapi/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularQuestions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularQuestions>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<PopularQuestions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PopularQuestions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopularQuestions>(null as any);
    }

    /**
     * Get list of popular questions of specific category.
     * @param category (optional) category id
     * @return return list of PopularQuestions objects
     */
    listbycategory(category: UserType | undefined): Observable<PopularQuestions[]> {
        let url_ = this.baseUrl + "/api/popularquestionsapi/listbycategory?";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbycategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbycategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopularQuestions[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopularQuestions[]>;
        }));
    }

    protected processListbycategory(response: HttpResponseBase): Observable<PopularQuestions[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PopularQuestions.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopularQuestions[]>(null as any);
    }
}

@Injectable()
export class ProductapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get list of products according to a provided filter.
     * @param body (optional) filter object
     * @return return list of ProductResponseModel objects
     */
    list(body: ProductFilterModel | undefined): Observable<ProductResponseModel> {
        let url_ = this.baseUrl + "/api/productapi/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductResponseModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ProductResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductResponseModel>(null as any);
    }

    /**
     * @return Success
     */
    listpoductswithvarients(): Observable<ProductModel[]> {
        let url_ = this.baseUrl + "/api/productapi/listpoductswithvarients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListpoductswithvarients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListpoductswithvarients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel[]>;
        }));
    }

    protected processListpoductswithvarients(response: HttpResponseBase): Observable<ProductModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModel[]>(null as any);
    }

    /**
     * Get product of specific id.
     * @param productId (optional) Product id
     * @return return Product object
     */
    single(productId: number | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/productapi/single?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * Create a Product.
     * @param body (optional) Product object
     * @return return the newly created product
     */
    create(body: Product | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/productapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * Update a product.
     * @param body (optional) Product id
     * @return return the updated Product
     */
    update(body: Product | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/productapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    delete(productId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/productapi/delete?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get list of all products.
     * @return return list of PopularQuestions objects
     */
    allproducts(): Observable<void> {
        let url_ = this.baseUrl + "/api/productapi/allproducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllproducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllproducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllproducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get list of products which have the same substring in the name.
     * @param name (optional) name of product
     * @return return list of ProductModel objects
     */
    getproductbyname(name: string | undefined): Observable<ProductModel[]> {
        let url_ = this.baseUrl + "/api/productapi/getproductbyname?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductbyname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductbyname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel[]>;
        }));
    }

    protected processGetproductbyname(response: HttpResponseBase): Observable<ProductModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModel[]>(null as any);
    }

    /**
     * Get list of products with discount.
     * @return return list of ProductModel objects
     */
    getproductwithdiscount(): Observable<ProductModel[]> {
        let url_ = this.baseUrl + "/api/productapi/getproductwithdiscount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductwithdiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductwithdiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel[]>;
        }));
    }

    protected processGetproductwithdiscount(response: HttpResponseBase): Observable<ProductModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModel[]>(null as any);
    }

    /**
     * Save Product Image on server.
     * @return return image path as string
     */
    uploadproductimage(): Observable<void> {
        let url_ = this.baseUrl + "/api/productapi/uploadproductimage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadproductimage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadproductimage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadproductimage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ReviewproductapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create a Review.
     * @param body (optional) review object
     * @return return BaseResponse object of boolean value
     */
    create(body: Review | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * Get Reviews of a specific product.
     * @param productId (optional) product Id
     * @return return BaseResponse object of list of Review
     */
    getreviewsbyproductid(productId: number | undefined): Observable<ReviewListBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/getreviewsbyproductid?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetreviewsbyproductid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetreviewsbyproductid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewListBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewListBaseResponse>;
        }));
    }

    protected processGetreviewsbyproductid(response: HttpResponseBase): Observable<ReviewListBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewListBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewListBaseResponse>(null as any);
    }

    /**
     * Get Rating of a product.
     * @param productId (optional) Product Id
     * @return return BaseResponse object of double value as rating
     */
    getratingofproduct(productId: number | undefined): Observable<DoubleBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewproductapi/getratingofproduct?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetratingofproduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetratingofproduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoubleBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoubleBaseResponse>;
        }));
    }

    protected processGetratingofproduct(response: HttpResponseBase): Observable<DoubleBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoubleBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoubleBaseResponse>(null as any);
    }
}

@Injectable()
export class ReviewuserapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create a Review of Vendor.
     * @param body (optional) UserReview object
     * @return return BaseResponse object of boolean value
     */
    create(body: UserReview | undefined): Observable<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/reviewuserapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanBaseResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BooleanBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanBaseResponse>(null as any);
    }

    /**
     * Get Reviews of a specific vendor.
     * @param userId (optional) vendor id
     * @return return List of ReviewUserResponse
     */
    getreviewsbyuserid(userId: string | undefined): Observable<ReviewUserResponse[]> {
        let url_ = this.baseUrl + "/api/reviewuserapi/getreviewsbyuserid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetreviewsbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetreviewsbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewUserResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewUserResponse[]>;
        }));
    }

    protected processGetreviewsbyuserid(response: HttpResponseBase): Observable<ReviewUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReviewUserResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewUserResponse[]>(null as any);
    }

    /**
     * Get Rating of a Vendor.
     * @param userId (optional) vendor Id
     * @return return double value as rating
     */
    getratingofuser(userId: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/reviewuserapi/getratingofuser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetratingofuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetratingofuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetratingofuser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ServerequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get all Serve Me requests assigned to the logged in driver.
     * @return List of Serve me requests
     */
    getallbydriverid(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getallbydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallbydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallbydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetallbydriverid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * Get Serve me request of a specific id.
     * @param id (optional) id of Serve Me request
     * @return Serve Me object
     */
    getrequestbyid(id: number | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processGetrequestbyid(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * Get all Serve Me requests of status pending assigned to the logged in driver.
     * @return List of Serve me objects
     */
    getservemependingsbydriverid(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getservemependingsbydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetservemependingsbydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetservemependingsbydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetservemependingsbydriverid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * Get all Serve Me requests of status Delivered/UnDelivered assigned to the logged in driver.
     * @return List of Serve me objects
     */
    getservemedonebydriverid(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getservemedonebydriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetservemedonebydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetservemedonebydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetservemedonebydriverid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * Create new Serve Me request for the logged in user and send notification to admins.
     * @param body (optional) Serve Me object
     * @return the newly created Serve Me object
     */
    addrequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/addrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddrequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddrequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processAddrequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * Update Serve Me request.
     * @param body (optional) Serve Me object
     * @return the updated Serve Me object
     */
    updaterequest(body: ServeMe | undefined): Observable<ServeMe> {
        let url_ = this.baseUrl + "/api/serverequest/updaterequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdaterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdaterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe>;
        }));
    }

    protected processUpdaterequest(response: HttpResponseBase): Observable<ServeMe> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServeMe.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe>(null as any);
    }

    /**
     * Delete specific Serve Me Request of of specific id.
     * @param id (optional) id of Serve Me Object
     * @return true if deleting is successful
     */
    deleterequest(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/serverequest/deleterequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleterequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleterequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleterequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get all Serve Me requests.
     * @return List of Serve me objects
     */
    getallrequests(): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getallrequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallrequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallrequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetallrequests(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }

    /**
     * Get all Serve Me requests created by a specific user.
     * @param creatorId (optional) id of user
     * @return List of Serve me objects
     */
    getrequestsbycreatorid(creatorId: string | undefined): Observable<ServeMe[]> {
        let url_ = this.baseUrl + "/api/serverequest/getrequestsbycreatorid?";
        if (creatorId === null)
            throw new Error("The parameter 'creatorId' cannot be null.");
        else if (creatorId !== undefined)
            url_ += "creatorId=" + encodeURIComponent("" + creatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetrequestsbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetrequestsbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServeMe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServeMe[]>;
        }));
    }

    protected processGetrequestsbycreatorid(response: HttpResponseBase): Observable<ServeMe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServeMe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServeMe[]>(null as any);
    }
}

@Injectable()
export class SuborderapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get List of SubOrders.
     * @return return List of SubOrderModel
     */
    list(): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Get SubOrder of specific id.
     * @param id (optional) suborder Id
     * @return return SubOrder
     */
    getbyid(id: number | undefined): Observable<SubOrder> {
        let url_ = this.baseUrl + "/api/suborderapi/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrder>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<SubOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrder>(null as any);
    }

    /**
     * Get List of SubOrders of specific Order.
     * @param id (optional) Order Id
     * @return return list of SubOrderModel objects
     */
    getbyorderid(id: number | undefined): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getbyorderid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyorderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyorderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processGetbyorderid(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Get List of SubOrders assigned to a specific driver.
     * @param id (optional) driver Id
     * @return return list of SubOrderModel objects
     */
    getbydriverid(id: string | undefined): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getbydriverid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbydriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbydriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processGetbydriverid(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Get List of SubOrders that belongs to a specific vendor.
     * @param id (optional) vendor Id
     * @return return list of SubOrderModel objects
     */
    getbyvendorid(id: string | undefined): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getbyvendorid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyvendorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyvendorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processGetbyvendorid(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Get List of suborders created by a specific user.
     * @param id (optional) user Id
     * @return return list of SubOrderModel objects
     */
    getbycreatorid(id: string | undefined): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getbycreatorid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbycreatorid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbycreatorid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processGetbycreatorid(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Update a Suborder.
     * @param body (optional) SubOrderModel Object
     * @return return the updated suborder
     */
    update(body: SubOrderModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/suborderapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get List of suborders of a specific status.
     * @param orderStatusType (optional) OrderStatusType object
     * @return return list of SubOrderModel objects
     */
    listbystatus(orderStatusType: OrderStatusType | undefined): Observable<SubOrderModel[]> {
        let url_ = this.baseUrl + "/api/suborderapi/listbystatus?";
        if (orderStatusType === null)
            throw new Error("The parameter 'orderStatusType' cannot be null.");
        else if (orderStatusType !== undefined)
            url_ += "orderStatusType=" + encodeURIComponent("" + orderStatusType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbystatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbystatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrderModel[]>;
        }));
    }

    protected processListbystatus(response: HttpResponseBase): Observable<SubOrderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrderModel[]>(null as any);
    }

    /**
     * Get Details of a specific suborder.
     * @param id (optional) suborder Id
     * @return return list of OrderDetail objects
     */
    getorderdetailsbysuborder(id: number | undefined): Observable<OrderDetail[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getorderdetailsbysuborder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetorderdetailsbysuborder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetorderdetailsbysuborder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetail[]>;
        }));
    }

    protected processGetorderdetailsbysuborder(response: HttpResponseBase): Observable<OrderDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrderDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetail[]>(null as any);
    }

    /**
     * Get available drivers for a specific suborder.
     * @param subOrderId (optional) suborder Id
     * @return return List of ApplicationUser objects
     */
    getfreedrivers(subOrderId: number | undefined): Observable<ApplicationUser[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getfreedrivers?";
        if (subOrderId === null)
            throw new Error("The parameter 'subOrderId' cannot be null.");
        else if (subOrderId !== undefined)
            url_ += "subOrderId=" + encodeURIComponent("" + subOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetfreedrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetfreedrivers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser[]>;
        }));
    }

    protected processGetfreedrivers(response: HttpResponseBase): Observable<ApplicationUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ApplicationUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser[]>(null as any);
    }

    /**
     * Get Subordrs assigned to a driver and waits his approve/reject.
     * @param driverId (optional) driver Id
     * @return return list of SubOrder objects
     */
    getdriverpendings(driverId: string | undefined): Observable<SubOrder[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getdriverpendings?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdriverpendings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdriverpendings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrder[]>;
        }));
    }

    protected processGetdriverpendings(response: HttpResponseBase): Observable<SubOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrder[]>(null as any);
    }

    /**
     * Get List of suborders assigned to a driver and are delivered/undelivered by him.
     * @param driverId (optional) vendor Id
     * @return return list of SubOrder objects
     */
    getdriverdoneorders(driverId: string | undefined): Observable<SubOrder[]> {
        let url_ = this.baseUrl + "/api/suborderapi/getdriverdoneorders?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdriverdoneorders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdriverdoneorders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubOrder[]>;
        }));
    }

    protected processGetdriverdoneorders(response: HttpResponseBase): Observable<SubOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubOrder[]>(null as any);
    }
}

@Injectable()
export class TrackingapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create Tracking of SubOrder and Update SubOrder Status.
     * @param body (optional) Tracking object
     */
    create(body: Tracking | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/trackingapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Update a Tracking.
     * @param body (optional) Tracking obj
     */
    update(body: Tracking | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/trackingapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get List of All Trackings.
     * @return return list of Tracking objects
     */
    list(): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/trackingapi/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * Get a Tracking of a specific id.
     * @param id (optional) Tracking Id
     * @return return a Tracking object
     */
    byid(id: number | undefined): Observable<Tracking> {
        let url_ = this.baseUrl + "/api/trackingapi/byid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking>;
        }));
    }

    protected processByid(response: HttpResponseBase): Observable<Tracking> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tracking.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking>(null as any);
    }

    /**
     * Get List of Trackings of specific Order.
     * @param id (optional) Order Id
     * @return return list of Tracking objects
     */
    listbyorderid(id: number | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/trackingapi/listbyorderid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbyorderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbyorderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processListbyorderid(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * Get List of Trackings of specific SubOrder.
     * @param id (optional) SubOrder Id
     * @return return list of Tracking objects
     */
    listbysuborderid(id: number | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/trackingapi/listbysuborderid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbysuborderid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbysuborderid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processListbysuborderid(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * Get List of Not Done Yet Trackings.
     * @return return list of Tracking objects
     */
    listnotdonetasks(): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/trackingapi/listnotdonetasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListnotdonetasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListnotdonetasks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processListnotdonetasks(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }

    /**
     * Get List of Trackings of status Delivered by specific driver.
     * @param userId (optional) driver Id
     * @return return list of Tracking objects
     */
    listdriverdonetasks(userId: string | undefined): Observable<Tracking[]> {
        let url_ = this.baseUrl + "/api/trackingapi/listdriverdonetasks?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListdriverdonetasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListdriverdonetasks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tracking[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tracking[]>;
        }));
    }

    protected processListdriverdonetasks(response: HttpResponseBase): Observable<Tracking[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tracking.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tracking[]>(null as any);
    }
}

@Injectable()
export class UserapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Authenticate Users by Email/Username and Password.
     * @param body (optional) LoginApiModel object
     * @return return LoginResponseModel object
     */
    login(body: LoginApiModel | undefined): Observable<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/userapi/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseModel>(null as any);
    }

    /**
     * Create account in Talabati database by Completing Registration Form.
     * @param body (optional) userRegisterModel object
     * @return return BaseResponse object of true/false
     */
    register(body: UserRegisterModel | undefined): Observable<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/userapi/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringBaseResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<StringBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringBaseResponse>(null as any);
    }

    /**
     * Save User Photo in server.
     * @param userId (optional) user Id
     * @param file (optional) 
     * @return return ApplicationUser object
     */
    uploaduserphoto(userId: string | undefined, file: FileParameter | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/userapi/uploaduserphoto?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaduserphoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaduserphoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processUploaduserphoto(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    /**
     * request a password reset in case a user forgets password , generates a token valid for short time and send the token to user email box.
     * @param email (optional) user email
     * @return return true if email is sent/email is not correct , false otherwise
     */
    forgetpasswordapp(email: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/forgetpasswordapp?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetpasswordapp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetpasswordapp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processForgetpasswordapp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Check Token Validity after password reset request.
     * @param token (optional) token for password reset
     * @param email (optional) user email
     * @return return true if password reset is successful ,false otherwise
     */
    checktokenforpassreset(token: string | undefined, email: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/checktokenforpassreset?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChecktokenforpassreset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChecktokenforpassreset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChecktokenforpassreset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Enter New Password after password Reset request and token validation.
     * @param body (optional) ResetPasswordViewModel object
     * @return return true if password is changed, false otherwise
     */
    resetpasswordapp(body: ResetPasswordViewModel | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/resetpasswordapp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetpasswordapp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetpasswordapp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetpasswordapp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get User of specific id.
     * @param userId (optional) user Id
     * @return return ApplicationUser object
     */
    getuserbyid(userId: string | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/userapi/getuserbyid?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetuserbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetuserbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processGetuserbyid(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    /**
     * Change User Password.
     * @param body (optional) EditUserAccount object
     * @return return true if password changed
     */
    changepassword(body: EditUserAccount | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangepassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangepassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangepassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Check Given Password if Valid for the Logged In User.
     * @param currentPass (optional) password
     * @return return true if password is valid for the specified user, false otherwise
     */
    checkpassword(currentPass: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/checkpassword?";
        if (currentPass === null)
            throw new Error("The parameter 'currentPass' cannot be null.");
        else if (currentPass !== undefined)
            url_ += "currentPass=" + encodeURIComponent("" + currentPass) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckpassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckpassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Change Logged In user status to online.
     * @return return True if status is changed
     */
    goonline(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/goonline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGoonline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGoonline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGoonline(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Change Logged In user status to offline.
     * @return return false if status is changed to offline
     */
    gooffline(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/gooffline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGooffline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGooffline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGooffline(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Check if logged In user is online.
     * @return return true if user is online
     */
    isonline(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/isonline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsonline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsonline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsonline(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Save Driver Photo on Server.
     * @return return Ok result with image path
     */
    uploaddriverphoto(): Observable<void> {
        let url_ = this.baseUrl + "/api/userapi/uploaddriverphoto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaddriverphoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaddriverphoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploaddriverphoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Save Driver ID on Server.
     * @return return Ok result with image path
     */
    uploaddriverid(): Observable<void> {
        let url_ = this.baseUrl + "/api/userapi/uploaddriverid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaddriverid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaddriverid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploaddriverid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Save Driver License on Server.
     * @return return Ok result with image path
     */
    uploaddriverlicense(): Observable<void> {
        let url_ = this.baseUrl + "/api/userapi/uploaddriverlicense";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaddriverlicense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaddriverlicense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploaddriverlicense(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Save vehicle Photo on Server.
     * @return return Ok result with image path
     */
    uploadvehiclepicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/userapi/uploadvehiclepicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadvehiclepicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadvehiclepicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadvehiclepicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param uid (optional) 
     * @param acco (optional) 
     * @param job (optional) 
     * @return Success
     */
    edituser(uid: string | undefined, acco: number | undefined, job: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/edituser?";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        if (acco === null)
            throw new Error("The parameter 'acco' cannot be null.");
        else if (acco !== undefined)
            url_ += "acco=" + encodeURIComponent("" + acco) + "&";
        if (job === null)
            throw new Error("The parameter 'job' cannot be null.");
        else if (job !== undefined)
            url_ += "job=" + encodeURIComponent("" + job) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdituser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdituser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEdituser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Complete Driver Profile Information after registration.
     * @param body (optional) DriverCompleteProfile object
     * @return return true if updated
     */
    editdriver(body: DriverCompleteProfile | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userapi/editdriver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditdriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditdriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEditdriver(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get Details of Logged In User.
     * @return return UserDetails object
     */
    getuserdetails(): Observable<UserDetails> {
        let url_ = this.baseUrl + "/api/userapi/getuserdetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetuserdetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetuserdetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetails>;
        }));
    }

    protected processGetuserdetails(response: HttpResponseBase): Observable<UserDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetails>(null as any);
    }

    /**
     * Get User Files/images.
     * @return return list of UserFile objects
     */
    getmyfiles(): Observable<UserFile[]> {
        let url_ = this.baseUrl + "/api/userapi/getmyfiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmyfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmyfiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserFile[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserFile[]>;
        }));
    }

    protected processGetmyfiles(response: HttpResponseBase): Observable<UserFile[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserFile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFile[]>(null as any);
    }
}

@Injectable()
export class UserlocationapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * update current location (latitude, longitude) of driver.
     * @param body (optional) UserLocation object
     * @return return true if successfully updated
     */
    updatedriverlocation(body: UserLocation | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/userlocationapi/updatedriverlocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatedriverlocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatedriverlocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdatedriverlocation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Get location of specific driver.
     * @param driverId (optional) driver Id
     * @return return DriverLocation Object
     */
    getlocationbydriver(driverId: string | undefined): Observable<DriverLocation> {
        let url_ = this.baseUrl + "/api/userlocationapi/getlocationbydriver?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlocationbydriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlocationbydriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLocation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLocation>;
        }));
    }

    protected processGetlocationbydriver(response: HttpResponseBase): Observable<DriverLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLocation>(null as any);
    }

    /**
     * Get location (latitude, longitude) of specific suborder's driver.
     * @param subOrderId (optional) SubOrder Id
     * @return return Location Object
     */
    getlocationforsuborderdriver(subOrderId: number | undefined): Observable<Location> {
        let url_ = this.baseUrl + "/api/userlocationapi/getlocationforsuborderdriver?";
        if (subOrderId === null)
            throw new Error("The parameter 'subOrderId' cannot be null.");
        else if (subOrderId !== undefined)
            url_ += "subOrderId=" + encodeURIComponent("" + subOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlocationforsuborderdriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlocationforsuborderdriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processGetlocationforsuborderdriver(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Location.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Location>(null as any);
    }
}

@Injectable()
export class VarientapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    listbyproductid(productId: number | undefined): Observable<Varient[]> {
        let url_ = this.baseUrl + "/api/varientapi/listbyproductid?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListbyproductid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListbyproductid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Varient[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Varient[]>;
        }));
    }

    protected processListbyproductid(response: HttpResponseBase): Observable<Varient[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Varient.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Varient[]>(null as any);
    }

    /**
     * Get Varient of specific id.
     * @param varientId (optional) varient Id
     * @return return Varient object
     */
    single(varientId: number | undefined): Observable<Varient> {
        let url_ = this.baseUrl + "/api/varientapi/single?";
        if (varientId === null)
            throw new Error("The parameter 'varientId' cannot be null.");
        else if (varientId !== undefined)
            url_ += "varientId=" + encodeURIComponent("" + varientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Varient>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Varient>;
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<Varient> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Varient.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Varient>(null as any);
    }

    /**
     * Create a Vrient.
     * @param body (optional) varient object
     * @return return the newly created varient
     */
    create(body: Varient | undefined): Observable<Varient> {
        let url_ = this.baseUrl + "/api/varientapi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Varient>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Varient>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Varient> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Varient.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Varient>(null as any);
    }

    /**
     * Update a Varient.
     * @param body (optional) varient object
     * @return return the updated varient
     */
    update(body: Varient | undefined): Observable<Varient> {
        let url_ = this.baseUrl + "/api/varientapi/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Varient>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Varient>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Varient> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Varient.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Varient>(null as any);
    }

    /**
     * Delete a Varient.
     * @param varientId (optional) varient Id
     * @return return true if varient is deleted
     */
    delete(varientId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/varientapi/delete?";
        if (varientId === null)
            throw new Error("The parameter 'varientId' cannot be null.");
        else if (varientId !== undefined)
            url_ += "varientId=" + encodeURIComponent("" + varientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Save varient image on server.
     * @return return varient image path as string
     */
    uploadvarientimage(): Observable<void> {
        let url_ = this.baseUrl + "/api/varientapi/uploadvarientimage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadvarientimage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadvarientimage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadvarientimage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get list of Color Varients.
     * @return return list of Color objects
     */
    getcolorlist(): Observable<Color[]> {
        let url_ = this.baseUrl + "/api/varientapi/getcolorlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcolorlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcolorlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Color[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Color[]>;
        }));
    }

    protected processGetcolorlist(response: HttpResponseBase): Observable<Color[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Color.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Color[]>(null as any);
    }

    /**
     * Get list of Size Varients.
     * @return return list of Size objects
     */
    getsizelist(): Observable<Size[]> {
        let url_ = this.baseUrl + "/api/varientapi/getsizelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsizelist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsizelist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Size[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Size[]>;
        }));
    }

    protected processGetsizelist(response: HttpResponseBase): Observable<Size[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Size.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Size[]>(null as any);
    }
}

@Injectable()
export class VendorapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Categories of Vendors.
     * @return return List of VendorCategory
     */
    categories(): Observable<VendorCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorCategory[]>;
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<VendorCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorCategory[]>(null as any);
    }

    /**
     * Get Sub Categories of specific Vendor's Category.
     * @param catId (optional) Category Id
     * @return return List of VendorSubCategory
     */
    subcategories(catId: number | undefined): Observable<VendorSubCategory[]> {
        let url_ = this.baseUrl + "/api/vendorapi/subcategories?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorSubCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorSubCategory[]>;
        }));
    }

    protected processSubcategories(response: HttpResponseBase): Observable<VendorSubCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorSubCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorSubCategory[]>(null as any);
    }

    /**
     * Get Vendors belonging to a specific Category.
     * @param catId (optional) Category Id
     * @return return List of UserResponseModel
     */
    vendorsbycatid(catId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbycatid?";
        if (catId === null)
            throw new Error("The parameter 'catId' cannot be null.");
        else if (catId !== undefined)
            url_ += "catId=" + encodeURIComponent("" + catId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbycatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbycatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbycatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * Get Vendors belonging to a specific Sub Category.
     * @param subCatId (optional) Sub Category Id
     * @return return list of UserResponseModel
     */
    vendorsbysubcatid(subCatId: number | undefined): Observable<UserResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorsbysubcatid?";
        if (subCatId === null)
            throw new Error("The parameter 'subCatId' cannot be null.");
        else if (subCatId !== undefined)
            url_ += "subCatId=" + encodeURIComponent("" + subCatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorsbysubcatid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorsbysubcatid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel[]>;
        }));
    }

    protected processVendorsbysubcatid(response: HttpResponseBase): Observable<UserResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel[]>(null as any);
    }

    /**
     * Get a specific Vendor.
     * @param vendorId (optional) Vendor Id
     * @return return UserResponseModel Object
     */
    vendorbyid(vendorId: string | undefined): Observable<UserResponseModel> {
        let url_ = this.baseUrl + "/api/vendorapi/vendorbyid?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendorbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendorbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseModel>;
        }));
    }

    protected processVendorbyid(response: HttpResponseBase): Observable<UserResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseModel>(null as any);
    }
}

@Injectable()
export class VendorwishlistapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * get Favourite Vendors of specific user.
     * @param userId (optional) user Id
     * @return return list of VendorWishListResponseModel
     */
    getwishlist(userId: string | undefined): Observable<VendorWishListResponseModel[]> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/getwishlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorWishListResponseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorWishListResponseModel[]>;
        }));
    }

    protected processGetwishlist(response: HttpResponseBase): Observable<VendorWishListResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VendorWishListResponseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorWishListResponseModel[]>(null as any);
    }

    /**
     * Add a vendor to a user's wish list.
     * @param body (optional) VendorWishlist object
     * @return return true if successfully added
     */
    createwish(body: VendorWishlist | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/createwish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Remove a vendor from a user's wish list.
     * @param wishId (optional) wish id
     * @return return true if successfully removed
     */
    deletewish(wishId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/vendorwishlistapi/deletewish?";
        if (wishId === null)
            throw new Error("The parameter 'wishId' cannot be null.");
        else if (wishId !== undefined)
            url_ += "wishId=" + encodeURIComponent("" + wishId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class WishlistapiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * get Favourite Products of specific user.
     * @param userId (optional) user Id
     * @return return list of WishListModel
     */
    getwishlist(userId: string | undefined): Observable<WishListModel[]> {
        let url_ = this.baseUrl + "/api/wishlistapi/getwishlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WishListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WishListModel[]>;
        }));
    }

    protected processGetwishlist(response: HttpResponseBase): Observable<WishListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WishListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WishListModel[]>(null as any);
    }

    /**
     * @param productId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    isfav(productId: number | undefined, userId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/isfav?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsfav(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsfav(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsfav(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Add a product to a user's wish list.
     * @param body (optional) Wishlist object
     * @return return true if successfully added
     */
    createwish(body: Wishlist | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/createwish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreatewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Remove a product from a user's wish list.
     * @param wishId (optional) wish id
     * @return return true if successfully removed
     */
    deletewish(wishId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/deletewish?";
        if (wishId === null)
            throw new Error("The parameter 'wishId' cannot be null.");
        else if (wishId !== undefined)
            url_ += "wishId=" + encodeURIComponent("" + wishId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletewish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletewish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletewish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    deletewishbyproductid(productId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/wishlistapi/deletewishbyproductid?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletewishbyproductid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletewishbyproductid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletewishbyproductid(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

export enum AccessControl {
    View = 1,
    Create = 2,
    Update = 3,
    Delete = 4,
    Status = 5,
}

export enum AccommodationType {
    Villa = 1,
    LargeApartement = 2,
    House = 3,
    SmallApartement = 4,
    Shops = 5,
    Other = 6,
}

export enum AddressType {
    Home = 0,
    Work = 1,
}

export class ApplicationRole implements IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;
    rolePermissions: RolePermissions[] | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.arabicName = _data["arabicName"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions.push(RolePermissions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["arabicName"] = this.arabicName;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
    userRoles: ApplicationUserRole[] | undefined;
    arabicName: string | undefined;
    rolePermissions: RolePermissions[] | undefined;
}

export class ApplicationUser implements IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    rating: number;
    vehicleType: string | undefined;
    userJobType: UserJobType;
    accommodationType: AccommodationType;
    isOnline: boolean;
    userWhish: VendorWishlist[] | undefined;
    vendorWish: VendorWishlist[] | undefined;
    userReviews: UserReview[] | undefined;
    ratersReviews: UserReview[] | undefined;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    coupons: Coupon[] | undefined;
    banners: Banner[] | undefined;
    readonly isActiveMarge: boolean;
    notificationToken: string | undefined;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isOnline = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(ApplicationUserRole.fromJS(item));
            }
            this.name = _data["name"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
            this.isActive = _data["isActive"];
            this.isApproved = _data["isApproved"];
            this.rating = _data["rating"];
            this.vehicleType = _data["vehicleType"];
            this.userJobType = _data["userJobType"];
            this.accommodationType = _data["accommodationType"];
            this.isOnline = _data["isOnline"] !== undefined ? _data["isOnline"] : true;
            if (Array.isArray(_data["userWhish"])) {
                this.userWhish = [] as any;
                for (let item of _data["userWhish"])
                    this.userWhish.push(VendorWishlist.fromJS(item));
            }
            if (Array.isArray(_data["vendorWish"])) {
                this.vendorWish = [] as any;
                for (let item of _data["vendorWish"])
                    this.vendorWish.push(VendorWishlist.fromJS(item));
            }
            if (Array.isArray(_data["userReviews"])) {
                this.userReviews = [] as any;
                for (let item of _data["userReviews"])
                    this.userReviews.push(UserReview.fromJS(item));
            }
            if (Array.isArray(_data["ratersReviews"])) {
                this.ratersReviews = [] as any;
                for (let item of _data["ratersReviews"])
                    this.ratersReviews.push(UserReview.fromJS(item));
            }
            if (Array.isArray(_data["vendorCovers"])) {
                this.vendorCovers = [] as any;
                for (let item of _data["vendorCovers"])
                    this.vendorCovers.push(VendorCover.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons.push(Coupon.fromJS(item));
            }
            if (Array.isArray(_data["banners"])) {
                this.banners = [] as any;
                for (let item of _data["banners"])
                    this.banners.push(Banner.fromJS(item));
            }
            (<any>this).isActiveMarge = _data["isActiveMarge"];
            this.notificationToken = _data["notificationToken"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        data["isActive"] = this.isActive;
        data["isApproved"] = this.isApproved;
        data["rating"] = this.rating;
        data["vehicleType"] = this.vehicleType;
        data["userJobType"] = this.userJobType;
        data["accommodationType"] = this.accommodationType;
        data["isOnline"] = this.isOnline;
        if (Array.isArray(this.userWhish)) {
            data["userWhish"] = [];
            for (let item of this.userWhish)
                data["userWhish"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorWish)) {
            data["vendorWish"] = [];
            for (let item of this.vendorWish)
                data["vendorWish"].push(item.toJSON());
        }
        if (Array.isArray(this.userReviews)) {
            data["userReviews"] = [];
            for (let item of this.userReviews)
                data["userReviews"].push(item.toJSON());
        }
        if (Array.isArray(this.ratersReviews)) {
            data["ratersReviews"] = [];
            for (let item of this.ratersReviews)
                data["ratersReviews"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorCovers)) {
            data["vendorCovers"] = [];
            for (let item of this.vendorCovers)
                data["vendorCovers"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item.toJSON());
        }
        if (Array.isArray(this.banners)) {
            data["banners"] = [];
            for (let item of this.banners)
                data["banners"].push(item.toJSON());
        }
        data["isActiveMarge"] = this.isActiveMarge;
        data["notificationToken"] = this.notificationToken;
        return data;
    }

    clone(): ApplicationUser {
        const json = this.toJSON();
        let result = new ApplicationUser();
        result.init(json);
        return result;
    }
}

export interface IApplicationUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    userRoles: ApplicationUserRole[] | undefined;
    name: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    isApproved: boolean;
    rating: number;
    vehicleType: string | undefined;
    userJobType: UserJobType;
    accommodationType: AccommodationType;
    isOnline: boolean;
    userWhish: VendorWishlist[] | undefined;
    vendorWish: VendorWishlist[] | undefined;
    userReviews: UserReview[] | undefined;
    ratersReviews: UserReview[] | undefined;
    vendorCovers: VendorCover[] | undefined;
    review: Review[] | undefined;
    order: Order[] | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
    coupons: Coupon[] | undefined;
    banners: Banner[] | undefined;
    isActiveMarge: boolean;
    notificationToken: string | undefined;
}

export class ApplicationUserRole implements IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;

    constructor(data?: IApplicationUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): ApplicationUserRole {
        const json = this.toJSON();
        let result = new ApplicationUserRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserRole {
    userId: string | undefined;
    roleId: string | undefined;
    user: ApplicationUser;
    role: ApplicationRole;
}

export class Banner implements IBanner {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userId: string | undefined;
    user: ApplicationUser;

    constructor(data?: IBanner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Banner {
        data = typeof data === 'object' ? data : {};
        let result = new Banner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): Banner {
        const json = this.toJSON();
        let result = new Banner();
        result.init(json);
        return result;
    }
}

export interface IBanner {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userId: string | undefined;
    user: ApplicationUser;
}

export class BooleanBaseResponse implements IBooleanBaseResponse {
    success: boolean;
    response: string | undefined;
    data: boolean;
    modelKey: string | undefined;

    constructor(data?: IBooleanBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): BooleanBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): BooleanBaseResponse {
        const json = this.toJSON();
        let result = new BooleanBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IBooleanBaseResponse {
    success: boolean;
    response: string | undefined;
    data: boolean;
    modelKey: string | undefined;
}

export class Brand implements IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Brand {
        const json = this.toJSON();
        let result = new Brand();
        result.init(json);
        return result;
    }
}

export interface IBrand {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
}

export class BuyMe implements IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IBuyMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BuyMe {
        data = typeof data === 'object' ? data : {};
        let result = new BuyMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): BuyMe {
        const json = this.toJSON();
        let result = new BuyMe();
        result.init(json);
        return result;
    }
}

export interface IBuyMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Category implements ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of _data["subCategory"])
                    this.subCategory.push(SubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): Category {
        const json = this.toJSON();
        let result = new Category();
        result.init(json);
        return result;
    }
}

export interface ICategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subCategory: SubCategory[] | undefined;
    product: Product[] | undefined;
}

export class ChatLog implements IChatLog {
    id: number;
    tid: number;
    senderId: string | undefined;
    sender: ApplicationUser;
    recieverId: string | undefined;
    reciever: ApplicationUser;
    text: string;
    sendingDate: moment.Moment;
    recievingDate: moment.Moment;
    read: boolean;
    notificationJson: string | undefined;
    responseJson: string | undefined;
    token: string | undefined;

    constructor(data?: IChatLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.senderId = _data["senderId"];
            this.sender = _data["sender"] ? ApplicationUser.fromJS(_data["sender"]) : <any>undefined;
            this.recieverId = _data["recieverId"];
            this.reciever = _data["reciever"] ? ApplicationUser.fromJS(_data["reciever"]) : <any>undefined;
            this.text = _data["text"];
            this.sendingDate = _data["sendingDate"] ? moment(_data["sendingDate"].toString()) : <any>undefined;
            this.recievingDate = _data["recievingDate"] ? moment(_data["recievingDate"].toString()) : <any>undefined;
            this.read = _data["read"];
            this.notificationJson = _data["notificationJson"];
            this.responseJson = _data["responseJson"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ChatLog {
        data = typeof data === 'object' ? data : {};
        let result = new ChatLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["senderId"] = this.senderId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["recieverId"] = this.recieverId;
        data["reciever"] = this.reciever ? this.reciever.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["sendingDate"] = this.sendingDate ? this.sendingDate.toISOString() : <any>undefined;
        data["recievingDate"] = this.recievingDate ? this.recievingDate.toISOString() : <any>undefined;
        data["read"] = this.read;
        data["notificationJson"] = this.notificationJson;
        data["responseJson"] = this.responseJson;
        data["token"] = this.token;
        return data;
    }

    clone(): ChatLog {
        const json = this.toJSON();
        let result = new ChatLog();
        result.init(json);
        return result;
    }
}

export interface IChatLog {
    id: number;
    tid: number;
    senderId: string | undefined;
    sender: ApplicationUser;
    recieverId: string | undefined;
    reciever: ApplicationUser;
    text: string;
    sendingDate: moment.Moment;
    recievingDate: moment.Moment;
    read: boolean;
    notificationJson: string | undefined;
    responseJson: string | undefined;
    token: string | undefined;
}

export class ChatLogListBaseResponse implements IChatLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: ChatLog[] | undefined;
    modelKey: string | undefined;

    constructor(data?: IChatLogListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ChatLog.fromJS(item));
            }
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): ChatLogListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatLogListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): ChatLogListBaseResponse {
        const json = this.toJSON();
        let result = new ChatLogListBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IChatLogListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: ChatLog[] | undefined;
    modelKey: string | undefined;
}

export class Color implements IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: IColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.colorCode = _data["colorCode"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Color {
        data = typeof data === 'object' ? data : {};
        let result = new Color();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["colorCode"] = this.colorCode;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Color {
        const json = this.toJSON();
        let result = new Color();
        result.init(json);
        return result;
    }
}

export interface IColor {
    id: number;
    tid: number;
    name: string;
    colorCode: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class Coupon implements ICoupon {
    id: number;
    tid: number;
    couponCode: string;
    discountType: string;
    discountValue: number;
    maxDiscountAmount: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    createdDate: moment.Moment;
    status: boolean;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.couponCode = _data["couponCode"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.maxDiscountAmount = _data["maxDiscountAmount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["couponCode"] = this.couponCode;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["maxDiscountAmount"] = this.maxDiscountAmount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Coupon {
        const json = this.toJSON();
        let result = new Coupon();
        result.init(json);
        return result;
    }
}

export interface ICoupon {
    id: number;
    tid: number;
    couponCode: string;
    discountType: string;
    discountValue: number;
    maxDiscountAmount: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    createdDate: moment.Moment;
    status: boolean;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class CouponBaseResponse implements ICouponBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Coupon;
    modelKey: string | undefined;

    constructor(data?: ICouponBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"] ? Coupon.fromJS(_data["data"]) : <any>undefined;
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): CouponBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CouponBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): CouponBaseResponse {
        const json = this.toJSON();
        let result = new CouponBaseResponse();
        result.init(json);
        return result;
    }
}

export interface ICouponBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Coupon;
    modelKey: string | undefined;
}

export class DoubleBaseResponse implements IDoubleBaseResponse {
    success: boolean;
    response: string | undefined;
    data: number;
    modelKey: string | undefined;

    constructor(data?: IDoubleBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): DoubleBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): DoubleBaseResponse {
        const json = this.toJSON();
        let result = new DoubleBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IDoubleBaseResponse {
    success: boolean;
    response: string | undefined;
    data: number;
    modelKey: string | undefined;
}

export class DriverCompleteProfile implements IDriverCompleteProfile {
    firstname: string | undefined;
    lastname: string | undefined;
    middlename: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    vehicleType: string | undefined;

    constructor(data?: IDriverCompleteProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.middlename = _data["middlename"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.vehicleType = _data["vehicleType"];
        }
    }

    static fromJS(data: any): DriverCompleteProfile {
        data = typeof data === 'object' ? data : {};
        let result = new DriverCompleteProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["middlename"] = this.middlename;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["vehicleType"] = this.vehicleType;
        return data;
    }

    clone(): DriverCompleteProfile {
        const json = this.toJSON();
        let result = new DriverCompleteProfile();
        result.init(json);
        return result;
    }
}

export interface IDriverCompleteProfile {
    firstname: string | undefined;
    lastname: string | undefined;
    middlename: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    vehicleType: string | undefined;
}

export class DriverLocation implements IDriverLocation {
    id: number;
    driverId: string | undefined;
    driver: ApplicationUser;
    latitude: number;
    longitude: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;

    constructor(data?: IDriverLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.driverId = _data["driverId"];
            this.driver = _data["driver"] ? ApplicationUser.fromJS(_data["driver"]) : <any>undefined;
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DriverLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["driverId"] = this.driverId;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>undefined;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): DriverLocation {
        const json = this.toJSON();
        let result = new DriverLocation();
        result.init(json);
        return result;
    }
}

export interface IDriverLocation {
    id: number;
    driverId: string | undefined;
    driver: ApplicationUser;
    latitude: number;
    longitude: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;
}

export enum DriverPaperType {
    IdentityCard = 1,
    SelfPortrait = 2,
    DriverLicense = 3,
    VehiclePicture = 4,
}

export enum DriverTaskStatusType {
    OnTheWayToStore = 1,
    ArrivedAtStore = 2,
    OnTheWayToClient = 3,
    OrderIsDelivered = 4,
}

export class DynamicPageModel implements IDynamicPageModel {
    id: number;
    title: string;
    content: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment | undefined;
    updatedBy: string | undefined;
    publishedDate: moment.Moment | undefined;
    publishedBy: string | undefined;
    slug: string | undefined;
    isPublished: boolean;

    constructor(data?: IDynamicPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.publishedDate = _data["publishedDate"] ? moment(_data["publishedDate"].toString()) : <any>undefined;
            this.publishedBy = _data["publishedBy"];
            this.slug = _data["slug"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): DynamicPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["publishedDate"] = this.publishedDate ? this.publishedDate.toISOString() : <any>undefined;
        data["publishedBy"] = this.publishedBy;
        data["slug"] = this.slug;
        data["isPublished"] = this.isPublished;
        return data;
    }

    clone(): DynamicPageModel {
        const json = this.toJSON();
        let result = new DynamicPageModel();
        result.init(json);
        return result;
    }
}

export interface IDynamicPageModel {
    id: number;
    title: string;
    content: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment | undefined;
    updatedBy: string | undefined;
    publishedDate: moment.Moment | undefined;
    publishedBy: string | undefined;
    slug: string | undefined;
    isPublished: boolean;
}

export class EditUserAccount implements IEditUserAccount {
    name: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    currentPassword: string | undefined;
    newPassword: string | undefined;
    confirmPassword: string | undefined;

    constructor(data?: IEditUserAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): EditUserAccount {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): EditUserAccount {
        const json = this.toJSON();
        let result = new EditUserAccount();
        result.init(json);
        return result;
    }
}

export interface IEditUserAccount {
    name: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    currentPassword: string | undefined;
    newPassword: string | undefined;
    confirmPassword: string | undefined;
}

export class EWallet implements IEWallet {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    transactionType: TransactionType;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;

    constructor(data?: IEWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.transactionType = _data["transactionType"];
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): EWallet {
        data = typeof data === 'object' ? data : {};
        let result = new EWallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["transactionType"] = this.transactionType;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }

    clone(): EWallet {
        const json = this.toJSON();
        let result = new EWallet();
        result.init(json);
        return result;
    }
}

export interface IEWallet {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    transactionType: TransactionType;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
}

export class EWalletPromise implements IEWalletPromise {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    creator: ApplicationUser;
    notes: string | undefined;

    constructor(data?: IEWalletPromise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creator = _data["creator"] ? ApplicationUser.fromJS(_data["creator"]) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): EWalletPromise {
        data = typeof data === 'object' ? data : {};
        let result = new EWalletPromise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): EWalletPromise {
        const json = this.toJSON();
        let result = new EWalletPromise();
        result.init(json);
        return result;
    }
}

export interface IEWalletPromise {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    creator: ApplicationUser;
    notes: string | undefined;
}

export enum Gender {
    Male = 0,
    Female = 1,
}

export class Location implements ILocation {
    lat: number;
    lang: number;
    driver: string | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lang = _data["lang"];
            this.driver = _data["driver"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lang"] = this.lang;
        data["driver"] = this.driver;
        return data;
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    lat: number;
    lang: number;
    driver: string | undefined;
}

export class LoginApiModel implements ILoginApiModel {
    email: string | undefined;
    password: string | undefined;

    constructor(data?: ILoginApiModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginApiModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginApiModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): LoginApiModel {
        const json = this.toJSON();
        let result = new LoginApiModel();
        result.init(json);
        return result;
    }
}

export interface ILoginApiModel {
    email: string | undefined;
    password: string | undefined;
}

export class LoginResponseModel implements ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;

    constructor(data?: ILoginResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.token = _data["token"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.id = _data["id"];
            this.tid = _data["tid"];
        }
    }

    static fromJS(data: any): LoginResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["id"] = this.id;
        data["tid"] = this.tid;
        return data;
    }

    clone(): LoginResponseModel {
        const json = this.toJSON();
        let result = new LoginResponseModel();
        result.init(json);
        return result;
    }
}

export interface ILoginResponseModel {
    success: boolean;
    token: string | undefined;
    name: string | undefined;
    email: string | undefined;
    role: string | undefined;
    id: string | undefined;
    tid: number;
}

export class NotificationLog implements INotificationLog {
    id: number;
    token: string;
    userId: string | undefined;
    orderId: number | undefined;
    subOrderId: number | undefined;
    notificationJson: string;
    responseJson: string | undefined;
    isOpended: boolean;
    createdDate: moment.Moment;
    type: NotificationType;

    constructor(data?: INotificationLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.orderId = _data["orderId"];
            this.subOrderId = _data["subOrderId"];
            this.notificationJson = _data["notificationJson"];
            this.responseJson = _data["responseJson"];
            this.isOpended = _data["isOpended"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): NotificationLog {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["orderId"] = this.orderId;
        data["subOrderId"] = this.subOrderId;
        data["notificationJson"] = this.notificationJson;
        data["responseJson"] = this.responseJson;
        data["isOpended"] = this.isOpended;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }

    clone(): NotificationLog {
        const json = this.toJSON();
        let result = new NotificationLog();
        result.init(json);
        return result;
    }
}

export interface INotificationLog {
    id: number;
    token: string;
    userId: string | undefined;
    orderId: number | undefined;
    subOrderId: number | undefined;
    notificationJson: string;
    responseJson: string | undefined;
    isOpended: boolean;
    createdDate: moment.Moment;
    type: NotificationType;
}

export enum NotificationType {
    NewOrderForVendor = 1,
    FirstOrderForVendor = 2,
    FirstOrderForAdmin = 3,
    NewOrderForDriver = 4,
    NewServeMeForDriver = 5,
    NewBuyMeForDriver = 6,
    NewServeMeForAdmin = 7,
    NewBuyMeForAdmin = 8,
}

export class Order implements IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: Gender;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: AddressType;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string | undefined;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    paymentCompanyId: number | undefined;
    paymentReferenceCode: number | undefined;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    deliverLatitude: number;
    deliverLongitude: number;
    addressId: number | undefined;
    userAddress: UserAddress;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    readonly addressMarge: string | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.additionalMobile = _data["additionalMobile"];
            this.pincode = _data["pincode"];
            this.houseNo = _data["houseNo"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.area = _data["area"];
            this.landmark = _data["landmark"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.orderNotes = _data["orderNotes"];
            this.statements = _data["statements"];
            this.paymentMode = _data["paymentMode"];
            this.paymentCompanyId = _data["paymentCompanyId"];
            this.paymentReferenceCode = _data["paymentReferenceCode"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.shippingPincode = _data["shippingPincode"];
            this.shippingAmount = _data["shippingAmount"];
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.deliverLatitude = _data["deliverLatitude"];
            this.deliverLongitude = _data["deliverLongitude"];
            this.addressId = _data["addressId"];
            this.userAddress = _data["userAddress"] ? UserAddress.fromJS(_data["userAddress"]) : <any>undefined;
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
            if (Array.isArray(_data["tracking"])) {
                this.tracking = [] as any;
                for (let item of _data["tracking"])
                    this.tracking.push(Tracking.fromJS(item));
            }
            (<any>this).addressMarge = _data["addressMarge"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["additionalMobile"] = this.additionalMobile;
        data["pincode"] = this.pincode;
        data["houseNo"] = this.houseNo;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["area"] = this.area;
        data["landmark"] = this.landmark;
        data["city"] = this.city;
        data["state"] = this.state;
        data["orderNotes"] = this.orderNotes;
        data["statements"] = this.statements;
        data["paymentMode"] = this.paymentMode;
        data["paymentCompanyId"] = this.paymentCompanyId;
        data["paymentReferenceCode"] = this.paymentReferenceCode;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["shippingPincode"] = this.shippingPincode;
        data["shippingAmount"] = this.shippingAmount;
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["deliverLatitude"] = this.deliverLatitude;
        data["deliverLongitude"] = this.deliverLongitude;
        data["addressId"] = this.addressId;
        data["userAddress"] = this.userAddress ? this.userAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.tracking)) {
            data["tracking"] = [];
            for (let item of this.tracking)
                data["tracking"].push(item.toJSON());
        }
        data["addressMarge"] = this.addressMarge;
        return data;
    }

    clone(): Order {
        const json = this.toJSON();
        let result = new Order();
        result.init(json);
        return result;
    }
}

export interface IOrder {
    name: string;
    middleName: string;
    lastName: string;
    mobile: string;
    nickName: string | undefined;
    gender: Gender;
    additionalMobile: string | undefined;
    pincode: string | undefined;
    houseNo: string;
    address: string;
    addressType: AddressType;
    area: string;
    landmark: string | undefined;
    city: string;
    state: string | undefined;
    orderNotes: string | undefined;
    statements: boolean;
    paymentMode: PaymentModeType;
    paymentCompanyId: number | undefined;
    paymentReferenceCode: number | undefined;
    couponId: number;
    couponDiscount: number;
    shippingPincode: string | undefined;
    shippingAmount: number;
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    deliverLatitude: number;
    deliverLongitude: number;
    addressId: number | undefined;
    userAddress: UserAddress;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
    addressMarge: string | undefined;
}

export class OrderDetail implements IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    notes: string | undefined;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.subOrderId = _data["subOrderId"];
            this.subOrder = _data["subOrder"] ? SubOrder.fromJS(_data["subOrder"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): OrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["subOrderId"] = this.subOrderId;
        data["subOrder"] = this.subOrder ? this.subOrder.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): OrderDetail {
        const json = this.toJSON();
        let result = new OrderDetail();
        result.init(json);
        return result;
    }
}

export interface IOrderDetail {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    amount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    notes: string | undefined;
}

export class OrderDetailRequest implements IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    notes: string | undefined;
    varientId: number;
    vendorId: string | undefined;

    constructor(data?: IOrderDetailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.notes = _data["notes"];
            this.varientId = _data["varientId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): OrderDetailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["notes"] = this.notes;
        data["varientId"] = this.varientId;
        data["vendorId"] = this.vendorId;
        return data;
    }

    clone(): OrderDetailRequest {
        const json = this.toJSON();
        let result = new OrderDetailRequest();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailRequest {
    tid: number;
    productId: number;
    qty: number;
    price: number;
    amount: number;
    notes: string | undefined;
    varientId: number;
    vendorId: string | undefined;
}

export class OrderRequestModel implements IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    paymentCompanyId: number;
    paymentReferenceCode: number;
    shippingAmount: number;
    state: string | undefined;
    address: string;
    addressType: AddressType;
    mobile: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    middleName: string | undefined;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    createdBy: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;
    deliverLatitude: number;
    deliverLongitude: number;
    addressId: number | undefined;

    constructor(data?: IOrderRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tid = _data["tid"];
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.couponId = _data["couponId"];
            this.couponDiscount = _data["couponDiscount"];
            this.area = _data["area"];
            this.city = _data["city"];
            this.houseNo = _data["houseNo"];
            this.paymentMode = _data["paymentMode"];
            this.paymentCompanyId = _data["paymentCompanyId"];
            this.paymentReferenceCode = _data["paymentReferenceCode"];
            this.shippingAmount = _data["shippingAmount"];
            this.state = _data["state"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.mobile = _data["mobile"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.orderNotes = _data["orderNotes"];
            this.pincode = _data["pincode"];
            this.shippingPincode = _data["shippingPincode"];
            this.statements = _data["statements"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetailRequest.fromJS(item));
            }
            this.deliverLatitude = _data["deliverLatitude"];
            this.deliverLongitude = _data["deliverLongitude"];
            this.addressId = _data["addressId"];
        }
    }

    static fromJS(data: any): OrderRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tid"] = this.tid;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["couponId"] = this.couponId;
        data["couponDiscount"] = this.couponDiscount;
        data["area"] = this.area;
        data["city"] = this.city;
        data["houseNo"] = this.houseNo;
        data["paymentMode"] = this.paymentMode;
        data["paymentCompanyId"] = this.paymentCompanyId;
        data["paymentReferenceCode"] = this.paymentReferenceCode;
        data["shippingAmount"] = this.shippingAmount;
        data["state"] = this.state;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["mobile"] = this.mobile;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["orderNotes"] = this.orderNotes;
        data["pincode"] = this.pincode;
        data["shippingPincode"] = this.shippingPincode;
        data["statements"] = this.statements;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        data["deliverLatitude"] = this.deliverLatitude;
        data["deliverLongitude"] = this.deliverLongitude;
        data["addressId"] = this.addressId;
        return data;
    }

    clone(): OrderRequestModel {
        const json = this.toJSON();
        let result = new OrderRequestModel();
        result.init(json);
        return result;
    }
}

export interface IOrderRequestModel {
    tid: number;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    couponId: number;
    couponDiscount: number;
    area: string;
    city: string;
    houseNo: string;
    paymentMode: number;
    paymentCompanyId: number;
    paymentReferenceCode: number;
    shippingAmount: number;
    state: string | undefined;
    address: string;
    addressType: AddressType;
    mobile: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    middleName: string | undefined;
    orderNotes: string | undefined;
    pincode: string | undefined;
    shippingPincode: string | undefined;
    statements: string | undefined;
    createdBy: string | undefined;
    orderDetail: OrderDetailRequest[] | undefined;
    deliverLatitude: number;
    deliverLongitude: number;
    addressId: number | undefined;
}

export enum OrderStatusType {
    Pending = 1,
    Accepted = 2,
    Canceled = 3,
    TransmittedToVendor = 4,
    AcceptedByVendor = 5,
    InProcess = 6,
    TransmittedToDriver = 7,
    AcceptedByDriver = 8,
    RejectedByDriver = 9,
    ReTransmittedToDriver = 10,
    WaitingForDriver = 11,
    HandeledToDriver = 12,
    InTransit = 13,
    UnDelivered = 14,
    Delivered = 15,
    Failed = 16,
    Returned = 17,
    Temp = 18,
}

export class PaymentCompany implements IPaymentCompany {
    id: number;
    tid: number;
    name: string | undefined;
    logo: string | undefined;
    accountNumber: number;

    constructor(data?: IPaymentCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.logo = _data["logo"];
            this.accountNumber = _data["accountNumber"];
        }
    }

    static fromJS(data: any): PaymentCompany {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCompany();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["accountNumber"] = this.accountNumber;
        return data;
    }

    clone(): PaymentCompany {
        const json = this.toJSON();
        let result = new PaymentCompany();
        result.init(json);
        return result;
    }
}

export interface IPaymentCompany {
    id: number;
    tid: number;
    name: string | undefined;
    logo: string | undefined;
    accountNumber: number;
}

export enum PaymentModeType {
    COD = 1,
    Online = 2,
    EWallet = 3,
}

export class PaymentTransactionLog implements IPaymentTransactionLog {
    id: number;
    tid: number;
    orderId: number;
    userId: string | undefined;
    user: ApplicationUser;
    paymentCompanyName: string | undefined;
    paymentCompanyAccount: number;
    transactionReferenceCode: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;

    constructor(data?: IPaymentTransactionLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.paymentCompanyName = _data["paymentCompanyName"];
            this.paymentCompanyAccount = _data["paymentCompanyAccount"];
            this.transactionReferenceCode = _data["transactionReferenceCode"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): PaymentTransactionLog {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTransactionLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["paymentCompanyName"] = this.paymentCompanyName;
        data["paymentCompanyAccount"] = this.paymentCompanyAccount;
        data["transactionReferenceCode"] = this.transactionReferenceCode;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }

    clone(): PaymentTransactionLog {
        const json = this.toJSON();
        let result = new PaymentTransactionLog();
        result.init(json);
        return result;
    }
}

export interface IPaymentTransactionLog {
    id: number;
    tid: number;
    orderId: number;
    userId: string | undefined;
    user: ApplicationUser;
    paymentCompanyName: string | undefined;
    paymentCompanyAccount: number;
    transactionReferenceCode: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
}

export class Permissions implements IPermissions {
    id: number;
    tid: number;
    accessControl: AccessControl;
    entity: string | undefined;
    arabicName: string | undefined;

    constructor(data?: IPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.accessControl = _data["accessControl"];
            this.entity = _data["entity"];
            this.arabicName = _data["arabicName"];
        }
    }

    static fromJS(data: any): Permissions {
        data = typeof data === 'object' ? data : {};
        let result = new Permissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["accessControl"] = this.accessControl;
        data["entity"] = this.entity;
        data["arabicName"] = this.arabicName;
        return data;
    }

    clone(): Permissions {
        const json = this.toJSON();
        let result = new Permissions();
        result.init(json);
        return result;
    }
}

export interface IPermissions {
    id: number;
    tid: number;
    accessControl: AccessControl;
    entity: string | undefined;
    arabicName: string | undefined;
}

export class PopularQuestions implements IPopularQuestions {
    id: number;
    tid: number;
    question: string | undefined;
    answer: string | undefined;
    category: UserType;
    createdDate: string | undefined;
    createdBy: string | undefined;

    constructor(data?: IPopularQuestions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.question = _data["question"];
            this.answer = _data["answer"];
            this.category = _data["category"];
            this.createdDate = _data["createdDate"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): PopularQuestions {
        data = typeof data === 'object' ? data : {};
        let result = new PopularQuestions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["question"] = this.question;
        data["answer"] = this.answer;
        data["category"] = this.category;
        data["createdDate"] = this.createdDate;
        data["createdBy"] = this.createdBy;
        return data;
    }

    clone(): PopularQuestions {
        const json = this.toJSON();
        let result = new PopularQuestions();
        result.init(json);
        return result;
    }
}

export interface IPopularQuestions {
    id: number;
    tid: number;
    question: string | undefined;
    answer: string | undefined;
    category: UserType;
    createdDate: string | undefined;
    createdBy: string | undefined;
}

export class Product implements IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number | undefined;
    subCategory: SubCategory;
    subSubCategoryId: number | undefined;
    subSubCategory: SubSubCategory;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.subSubCategoryId = _data["subSubCategoryId"];
            this.subSubCategory = _data["subSubCategory"] ? SubSubCategory.fromJS(_data["subSubCategory"]) : <any>undefined;
            this.brandId = _data["brandId"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.rating = _data["rating"];
            this.mainImagePath = _data["mainImagePath"];
            this.hasVarient = _data["hasVarient"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.isRetunable = _data["isRetunable"];
            this.isCOD = _data["isCOD"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.purchaseCount = _data["purchaseCount"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
            if (Array.isArray(_data["productImage"])) {
                this.productImage = [] as any;
                for (let item of _data["productImage"])
                    this.productImage.push(ProductImage.fromJS(item));
            }
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["wishlist"])) {
                this.wishlist = [] as any;
                for (let item of _data["wishlist"])
                    this.wishlist.push(Wishlist.fromJS(item));
            }
            if (Array.isArray(_data["review"])) {
                this.review = [] as any;
                for (let item of _data["review"])
                    this.review.push(Review.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["subSubCategoryId"] = this.subSubCategoryId;
        data["subSubCategory"] = this.subSubCategory ? this.subSubCategory.toJSON() : <any>undefined;
        data["brandId"] = this.brandId;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["rating"] = this.rating;
        data["mainImagePath"] = this.mainImagePath;
        data["hasVarient"] = this.hasVarient;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["isRetunable"] = this.isRetunable;
        data["isCOD"] = this.isCOD;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["purchaseCount"] = this.purchaseCount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        if (Array.isArray(this.productImage)) {
            data["productImage"] = [];
            for (let item of this.productImage)
                data["productImage"].push(item.toJSON());
        }
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.wishlist)) {
            data["wishlist"] = [];
            for (let item of this.wishlist)
                data["wishlist"].push(item.toJSON());
        }
        if (Array.isArray(this.review)) {
            data["review"] = [];
            for (let item of this.review)
                data["review"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Product {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export interface IProduct {
    id: number;
    categoryId: number;
    category: Category;
    subCategoryId: number | undefined;
    subCategory: SubCategory;
    subSubCategoryId: number | undefined;
    subSubCategory: SubSubCategory;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    brand: Brand;
    tid: number;
    name: string;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    creatorUser: ApplicationUser;
    productImage: ProductImage[] | undefined;
    varient: Varient[] | undefined;
    userCart: UserCart[] | undefined;
    wishlist: Wishlist[] | undefined;
    review: Review[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class ProductFilterModel implements IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;

    constructor(data?: IProductFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.subSubCategory = _data["subSubCategory"];
            this.price = _data["price"];
            this.brand = _data["brand"];
            this.size = _data["size"];
            this.color = _data["color"];
            this.sortBy = _data["sortBy"];
            this.take = _data["take"];
            this.totalProducts = _data["totalProducts"];
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.creatorId = _data["creatorId"];
        }
    }

    static fromJS(data: any): ProductFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["subSubCategory"] = this.subSubCategory;
        data["price"] = this.price;
        data["brand"] = this.brand;
        data["size"] = this.size;
        data["color"] = this.color;
        data["sortBy"] = this.sortBy;
        data["take"] = this.take;
        data["totalProducts"] = this.totalProducts;
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["creatorId"] = this.creatorId;
        return data;
    }

    clone(): ProductFilterModel {
        const json = this.toJSON();
        let result = new ProductFilterModel();
        result.init(json);
        return result;
    }
}

export interface IProductFilterModel {
    category: string | undefined;
    subCategory: string | undefined;
    subSubCategory: string | undefined;
    price: string | undefined;
    brand: string | undefined;
    size: string | undefined;
    color: string | undefined;
    sortBy: SortByType;
    take: number;
    totalProducts: number;
    totalPages: number;
    currentPage: number;
    priceMax: number;
    selectedPriceMin: number;
    selectedPriceMax: number;
    creatorId: string | undefined;
}

export class ProductImage implements IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IProductImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): ProductImage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): ProductImage {
        const json = this.toJSON();
        let result = new ProductImage();
        result.init(json);
        return result;
    }
}

export interface IProductImage {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    imagePath: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class ProductModel implements IProductModel {
    id: number;
    tid: number;
    name: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    categoryId: number;
    subCategoryId: number | undefined;
    subSubCategoryId: number | undefined;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    varient: Varient[] | undefined;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.categoryId = _data["categoryId"];
            this.subCategoryId = _data["subCategoryId"];
            this.subSubCategoryId = _data["subSubCategoryId"];
            this.brandId = _data["brandId"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.rating = _data["rating"];
            this.mainImagePath = _data["mainImagePath"];
            this.hasVarient = _data["hasVarient"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.isRetunable = _data["isRetunable"];
            this.isCOD = _data["isCOD"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.purchaseCount = _data["purchaseCount"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["subSubCategoryId"] = this.subSubCategoryId;
        data["brandId"] = this.brandId;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["rating"] = this.rating;
        data["mainImagePath"] = this.mainImagePath;
        data["hasVarient"] = this.hasVarient;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["isRetunable"] = this.isRetunable;
        data["isCOD"] = this.isCOD;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["purchaseCount"] = this.purchaseCount;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductModel {
        const json = this.toJSON();
        let result = new ProductModel();
        result.init(json);
        return result;
    }
}

export interface IProductModel {
    id: number;
    tid: number;
    name: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    categoryId: number;
    subCategoryId: number | undefined;
    subSubCategoryId: number | undefined;
    brandId: number | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    shortDescription: string | undefined;
    longDescription: string | undefined;
    rating: number;
    mainImagePath: string | undefined;
    hasVarient: boolean;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    isRetunable: boolean;
    isCOD: boolean;
    status: boolean;
    isFeatured: boolean;
    purchaseCount: number;
    varient: Varient[] | undefined;
}

export class ProductResponseModel implements IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;

    constructor(data?: IProductResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products.push(Product.fromJS(item));
            }
            this.totalProducts = _data["totalProducts"];
            this.selectedPriceMax = _data["selectedPriceMax"];
            this.totalPages = _data["totalPages"];
            this.priceMax = _data["priceMax"];
            this.selectedPriceMin = _data["selectedPriceMin"];
        }
    }

    static fromJS(data: any): ProductResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["totalProducts"] = this.totalProducts;
        data["selectedPriceMax"] = this.selectedPriceMax;
        data["totalPages"] = this.totalPages;
        data["priceMax"] = this.priceMax;
        data["selectedPriceMin"] = this.selectedPriceMin;
        return data;
    }

    clone(): ProductResponseModel {
        const json = this.toJSON();
        let result = new ProductResponseModel();
        result.init(json);
        return result;
    }
}

export interface IProductResponseModel {
    products: Product[] | undefined;
    totalProducts: number;
    selectedPriceMax: number;
    totalPages: number;
    priceMax: number;
    selectedPriceMin: number;
}

export enum RequestStatusType {
    Pending = 1,
    AcceptedByDriver = 2,
    RejectedByDriver = 3,
    InTransit = 4,
    Delivered = 5,
    UnDelivered = 6,
    Failed = 7,
    Returned = 8,
    Temp = 9,
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    token: string;
    email: string;
    newPassword: string;
    confirmPassword: string;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): ResetPasswordViewModel {
        const json = this.toJSON();
        let result = new ResetPasswordViewModel();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordViewModel {
    token: string;
    email: string;
    newPassword: string;
    confirmPassword: string;
}

export class Review implements IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): Review {
        const json = this.toJSON();
        let result = new Review();
        result.init(json);
        return result;
    }
}

export interface IReview {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    userId: string | undefined;
    user: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;
}

export class ReviewListBaseResponse implements IReviewListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Review[] | undefined;
    modelKey: string | undefined;

    constructor(data?: IReviewListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Review.fromJS(item));
            }
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): ReviewListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): ReviewListBaseResponse {
        const json = this.toJSON();
        let result = new ReviewListBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IReviewListBaseResponse {
    success: boolean;
    response: string | undefined;
    data: Review[] | undefined;
    modelKey: string | undefined;
}

export enum ReviewStatusType {
    Pending = 0,
    Approved = 1,
    Rejected = 2,
}

export class ReviewUserResponse implements IReviewUserResponse {
    id: number;
    tid: number;
    userId: string | undefined;
    raterId: string | undefined;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IReviewUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.raterId = _data["raterId"];
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): ReviewUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["raterId"] = this.raterId;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): ReviewUserResponse {
        const json = this.toJSON();
        let result = new ReviewUserResponse();
        result.init(json);
        return result;
    }
}

export interface IReviewUserResponse {
    id: number;
    tid: number;
    userId: string | undefined;
    raterId: string | undefined;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class RolePermissions implements IRolePermissions {
    id: number;
    roleId: string | undefined;
    permissionsId: number;
    role: ApplicationRole;
    permission: Permissions;

    constructor(data?: IRolePermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionsId = _data["permissionsId"];
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
            this.permission = _data["permission"] ? Permissions.fromJS(_data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RolePermissions {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionsId"] = this.permissionsId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data;
    }

    clone(): RolePermissions {
        const json = this.toJSON();
        let result = new RolePermissions();
        result.init(json);
        return result;
    }
}

export interface IRolePermissions {
    id: number;
    roleId: string | undefined;
    permissionsId: number;
    role: ApplicationRole;
    permission: Permissions;
}

export class ServeMe implements IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;

    constructor(data?: IServeMe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.status = _data["status"];
            this.orderDetails = _data["orderDetails"];
            this.senderAddress = _data["senderAddress"];
            this.senderDate = _data["senderDate"] ? moment(_data["senderDate"].toString()) : <any>undefined;
            this.recieverAddress = _data["recieverAddress"];
            this.recieverDate = _data["recieverDate"] ? moment(_data["recieverDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.creatorUser = _data["creatorUser"] ? ApplicationUser.fromJS(_data["creatorUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServeMe {
        data = typeof data === 'object' ? data : {};
        let result = new ServeMe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["status"] = this.status;
        data["orderDetails"] = this.orderDetails;
        data["senderAddress"] = this.senderAddress;
        data["senderDate"] = this.senderDate ? this.senderDate.toISOString() : <any>undefined;
        data["recieverAddress"] = this.recieverAddress;
        data["recieverDate"] = this.recieverDate ? this.recieverDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): ServeMe {
        const json = this.toJSON();
        let result = new ServeMe();
        result.init(json);
        return result;
    }
}

export interface IServeMe {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    orderStatus: RequestStatusType;
    status: boolean;
    orderDetails: string | undefined;
    senderAddress: string | undefined;
    senderDate: moment.Moment;
    recieverAddress: string | undefined;
    recieverDate: moment.Moment;
    createdBy: string | undefined;
    creatorUser: ApplicationUser;
}

export class Size implements ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;

    constructor(data?: ISize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varient"])) {
                this.varient = [] as any;
                for (let item of _data["varient"])
                    this.varient.push(Varient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Size {
        data = typeof data === 'object' ? data : {};
        let result = new Size();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varient)) {
            data["varient"] = [];
            for (let item of this.varient)
                data["varient"].push(item.toJSON());
        }
        return data;
    }

    clone(): Size {
        const json = this.toJSON();
        let result = new Size();
        result.init(json);
        return result;
    }
}

export interface ISize {
    id: number;
    tid: number;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varient: Varient[] | undefined;
}

export class Slider implements ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: ISlider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.url = _data["url"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Slider {
        data = typeof data === 'object' ? data : {};
        let result = new Slider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["url"] = this.url;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Slider {
        const json = this.toJSON();
        let result = new Slider();
        result.init(json);
        return result;
    }
}

export interface ISlider {
    id: number;
    tid: number;
    imagePath: string | undefined;
    url: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export enum SortByType {
    SortByName = 1,
    PriceLowToHigh = 2,
    PriceHighToLow = 3,
}

export class StringBaseResponse implements IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;

    constructor(data?: IStringBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.response = _data["response"];
            this.data = _data["data"];
            this.modelKey = _data["modelKey"];
        }
    }

    static fromJS(data: any): StringBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["response"] = this.response;
        data["data"] = this.data;
        data["modelKey"] = this.modelKey;
        return data;
    }

    clone(): StringBaseResponse {
        const json = this.toJSON();
        let result = new StringBaseResponse();
        result.init(json);
        return result;
    }
}

export interface IStringBaseResponse {
    success: boolean;
    response: string | undefined;
    data: string | undefined;
    modelKey: string | undefined;
}

export class SubCategory implements ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;

    constructor(data?: ISubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["subSubCategory"])) {
                this.subSubCategory = [] as any;
                for (let item of _data["subSubCategory"])
                    this.subSubCategory.push(SubSubCategory.fromJS(item));
            }
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.subSubCategory)) {
            data["subSubCategory"] = [];
            for (let item of this.subSubCategory)
                data["subSubCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubCategory {
        const json = this.toJSON();
        let result = new SubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubCategory {
    id: number;
    tid: number;
    categoryId: number;
    category: Category;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    subSubCategory: SubSubCategory[] | undefined;
    product: Product[] | undefined;
}

export class SubOrder implements ISubOrder {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;

    constructor(data?: ISubOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.driverTaskStatus = _data["driverTaskStatus"];
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
            if (Array.isArray(_data["tracking"])) {
                this.tracking = [] as any;
                for (let item of _data["tracking"])
                    this.tracking.push(Tracking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SubOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["driverTaskStatus"] = this.driverTaskStatus;
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.tracking)) {
            data["tracking"] = [];
            for (let item of this.tracking)
                data["tracking"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubOrder {
        const json = this.toJSON();
        let result = new SubOrder();
        result.init(json);
        return result;
    }
}

export interface ISubOrder {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: OrderStatusType;
    driverTaskStatus: DriverTaskStatusType;
    orderDetail: OrderDetail[] | undefined;
    tracking: Tracking[] | undefined;
}

export class SubOrderModel implements ISubOrderModel {
    id: number;
    tid: number;
    orderId: number;
    vendorId: string | undefined;
    userId: string | undefined;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: number;
    driverTaskStatus: number;

    constructor(data?: ISubOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.vendorId = _data["vendorId"];
            this.userId = _data["userId"];
            this.totalQty = _data["totalQty"];
            this.totalAmount = _data["totalAmount"];
            this.taxPercent = _data["taxPercent"];
            this.taxAmount = _data["taxAmount"];
            this.grandTotal = _data["grandTotal"];
            this.orderStatus = _data["orderStatus"];
            this.driverTaskStatus = _data["driverTaskStatus"];
        }
    }

    static fromJS(data: any): SubOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["vendorId"] = this.vendorId;
        data["userId"] = this.userId;
        data["totalQty"] = this.totalQty;
        data["totalAmount"] = this.totalAmount;
        data["taxPercent"] = this.taxPercent;
        data["taxAmount"] = this.taxAmount;
        data["grandTotal"] = this.grandTotal;
        data["orderStatus"] = this.orderStatus;
        data["driverTaskStatus"] = this.driverTaskStatus;
        return data;
    }

    clone(): SubOrderModel {
        const json = this.toJSON();
        let result = new SubOrderModel();
        result.init(json);
        return result;
    }
}

export interface ISubOrderModel {
    id: number;
    tid: number;
    orderId: number;
    vendorId: string | undefined;
    userId: string | undefined;
    totalQty: number;
    totalAmount: number;
    taxPercent: number;
    taxAmount: number;
    grandTotal: number;
    orderStatus: number;
    driverTaskStatus: number;
}

export class SubSubCategory implements ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;

    constructor(data?: ISubSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.subCategoryId = _data["subCategoryId"];
            this.subCategory = _data["subCategory"] ? SubCategory.fromJS(_data["subCategory"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product.push(Product.fromJS(item));
            }
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): SubSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SubSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategory"] = this.subCategory ? this.subCategory.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item.toJSON());
        }
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): SubSubCategory {
        const json = this.toJSON();
        let result = new SubSubCategory();
        result.init(json);
        return result;
    }
}

export interface ISubSubCategory {
    id: number;
    tid: number;
    subCategoryId: number;
    subCategory: SubCategory;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    imagePath: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    product: Product[] | undefined;
    categoryId: number;
}

export class Tracking implements ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    endDate: moment.Moment;
    isDone: boolean;

    constructor(data?: ITracking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.subOrderId = _data["subOrderId"];
            this.subOrder = _data["subOrder"] ? SubOrder.fromJS(_data["subOrder"]) : <any>undefined;
            this.title = _data["title"];
            this.message = _data["message"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isDone = _data["isDone"];
        }
    }

    static fromJS(data: any): Tracking {
        data = typeof data === 'object' ? data : {};
        let result = new Tracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["subOrderId"] = this.subOrderId;
        data["subOrder"] = this.subOrder ? this.subOrder.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["message"] = this.message;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isDone"] = this.isDone;
        return data;
    }

    clone(): Tracking {
        const json = this.toJSON();
        let result = new Tracking();
        result.init(json);
        return result;
    }
}

export interface ITracking {
    id: number;
    tid: number;
    orderId: number;
    order: Order;
    subOrderId: number | undefined;
    subOrder: SubOrder;
    title: OrderStatusType;
    message: string;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    endDate: moment.Moment;
    isDone: boolean;
}

export enum TransactionType {
    Deposite = 1,
    Withdraw = -1,
}

export class UserAddress implements IUserAddress {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    address: string;
    addressTitle: string | undefined;
    area: string | undefined;
    city: string | undefined;
    houseNo: string | undefined;
    type: AddressType;
    status: boolean;
    latitude: number;
    longitude: number;
    landmark: string | undefined;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.address = _data["address"];
            this.addressTitle = _data["addressTitle"];
            this.area = _data["area"];
            this.city = _data["city"];
            this.houseNo = _data["houseNo"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.landmark = _data["landmark"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["addressTitle"] = this.addressTitle;
        data["area"] = this.area;
        data["city"] = this.city;
        data["houseNo"] = this.houseNo;
        data["type"] = this.type;
        data["status"] = this.status;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["landmark"] = this.landmark;
        return data;
    }

    clone(): UserAddress {
        const json = this.toJSON();
        let result = new UserAddress();
        result.init(json);
        return result;
    }
}

export interface IUserAddress {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    address: string;
    addressTitle: string | undefined;
    area: string | undefined;
    city: string | undefined;
    houseNo: string | undefined;
    type: AddressType;
    status: boolean;
    latitude: number;
    longitude: number;
    landmark: string | undefined;
}

export class UserCart implements IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;

    constructor(data?: IUserCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.tempUid = _data["tempUid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.total = _data["total"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCart {
        data = typeof data === 'object' ? data : {};
        let result = new UserCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["tempUid"] = this.tempUid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["total"] = this.total;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserCart {
        const json = this.toJSON();
        let result = new UserCart();
        result.init(json);
        return result;
    }
}

export interface IUserCart {
    id: number;
    tid: number;
    userId: string | undefined;
    tempUid: string | undefined;
    productId: number;
    product: Product;
    varientId: number | undefined;
    varient: Varient;
    qty: number;
    price: number;
    total: number;
    createdDate: moment.Moment;
    updatedDate: moment.Moment | undefined;
}

export class UserDetails implements IUserDetails {
    id: number;
    tid: number;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nickName: string | undefined;
    gender: number;
    address: string | undefined;
    addressType: number;
    mobile: string | undefined;
    additionalMobile: string | undefined;
    applicatioUserId: string | undefined;
    user: ApplicationUser;

    constructor(data?: IUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.mobile = _data["mobile"];
            this.additionalMobile = _data["additionalMobile"];
            this.applicatioUserId = _data["applicatioUserId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["mobile"] = this.mobile;
        data["additionalMobile"] = this.additionalMobile;
        data["applicatioUserId"] = this.applicatioUserId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserDetails {
        const json = this.toJSON();
        let result = new UserDetails();
        result.init(json);
        return result;
    }
}

export interface IUserDetails {
    id: number;
    tid: number;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nickName: string | undefined;
    gender: number;
    address: string | undefined;
    addressType: number;
    mobile: string | undefined;
    additionalMobile: string | undefined;
    applicatioUserId: string | undefined;
    user: ApplicationUser;
}

export class UserFile implements IUserFile {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    name: string | undefined;
    filePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    type: DriverPaperType;

    constructor(data?: IUserFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.name = _data["name"];
            this.filePath = _data["filePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UserFile {
        data = typeof data === 'object' ? data : {};
        let result = new UserFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["filePath"] = this.filePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["type"] = this.type;
        return data;
    }

    clone(): UserFile {
        const json = this.toJSON();
        let result = new UserFile();
        result.init(json);
        return result;
    }
}

export interface IUserFile {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    name: string | undefined;
    filePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    type: DriverPaperType;
}

export enum UserJobType {
    InternationalOrganization = 1,
    LocalOrganization = 2,
    BanksAndCompanies = 3,
    PrivateSector = 4,
    Shops = 5,
    Vocational = 6,
    PublicSector = 7,
    None = 8,
    Other = 9,
}

export class UserLocation implements IUserLocation {
    latitude: number;
    longitude: number;
    userId: string | undefined;

    constructor(data?: IUserLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserLocation {
        data = typeof data === 'object' ? data : {};
        let result = new UserLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserLocation {
        const json = this.toJSON();
        let result = new UserLocation();
        result.init(json);
        return result;
    }
}

export interface IUserLocation {
    latitude: number;
    longitude: number;
    userId: string | undefined;
}

export class UserRegisterModel implements IUserRegisterModel {
    name: string;
    middleName: string;
    lastName: string;
    nickName: string | undefined;
    gender: Gender;
    address: string | undefined;
    addressType: AddressType;
    mobile: string;
    additionalMobile: string | undefined;
    email: string;
    password: string;
    confirmPassword: string;
    statements: boolean;
    returnUrl: string | undefined;

    constructor(data?: IUserRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.nickName = _data["nickName"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.addressType = _data["addressType"];
            this.mobile = _data["mobile"];
            this.additionalMobile = _data["additionalMobile"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.statements = _data["statements"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): UserRegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nickName"] = this.nickName;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["addressType"] = this.addressType;
        data["mobile"] = this.mobile;
        data["additionalMobile"] = this.additionalMobile;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["statements"] = this.statements;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): UserRegisterModel {
        const json = this.toJSON();
        let result = new UserRegisterModel();
        result.init(json);
        return result;
    }
}

export interface IUserRegisterModel {
    name: string;
    middleName: string;
    lastName: string;
    nickName: string | undefined;
    gender: Gender;
    address: string | undefined;
    addressType: AddressType;
    mobile: string;
    additionalMobile: string | undefined;
    email: string;
    password: string;
    confirmPassword: string;
    statements: boolean;
    returnUrl: string | undefined;
}

export class UserResponseModel implements IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    vendorCovers: VendorCoversResponseModel[] | undefined;

    constructor(data?: IUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.tid = _data["tid"];
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories.push(VendorSubCategoryResponseModel.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.region = _data["region"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.storeLogo = _data["storeLogo"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["vendorCovers"])) {
                this.vendorCovers = [] as any;
                for (let item of _data["vendorCovers"])
                    this.vendorCovers.push(VendorCoversResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["tid"] = this.tid;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["region"] = this.region;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["storeLogo"] = this.storeLogo;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.vendorCovers)) {
            data["vendorCovers"] = [];
            for (let item of this.vendorCovers)
                data["vendorCovers"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserResponseModel {
        const json = this.toJSON();
        let result = new UserResponseModel();
        result.init(json);
        return result;
    }
}

export interface IUserResponseModel {
    id: string | undefined;
    name: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    vendorCategoryId: number | undefined;
    tid: number;
    subCategories: VendorSubCategoryResponseModel[] | undefined;
    createdDate: moment.Moment | undefined;
    region: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    storeLogo: string | undefined;
    isActive: boolean;
    vendorCovers: VendorCoversResponseModel[] | undefined;
}

export class UserReview implements IUserReview {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    raterId: string | undefined;
    rater: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IUserReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.raterId = _data["raterId"];
            this.rater = _data["rater"] ? ApplicationUser.fromJS(_data["rater"]) : <any>undefined;
            this.rating = _data["rating"];
            this.commentText = _data["commentText"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): UserReview {
        data = typeof data === 'object' ? data : {};
        let result = new UserReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["raterId"] = this.raterId;
        data["rater"] = this.rater ? this.rater.toJSON() : <any>undefined;
        data["rating"] = this.rating;
        data["commentText"] = this.commentText;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): UserReview {
        const json = this.toJSON();
        let result = new UserReview();
        result.init(json);
        return result;
    }
}

export interface IUserReview {
    id: number;
    tid: number;
    userId: string | undefined;
    user: ApplicationUser;
    raterId: string | undefined;
    rater: ApplicationUser;
    rating: number;
    commentText: string | undefined;
    status: ReviewStatusType;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    returnUrl: string | undefined;
}

export enum UserType {
    SuperAdmin = 0,
    Admin = 1,
    User = 2,
    Vendor = 3,
    Driver = 4,
}

export class UserVendorSubCategory implements IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;

    constructor(data?: IUserVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.vendorSubCategoryId = _data["vendorSubCategoryId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.vendorSubCategory = _data["vendorSubCategory"] ? VendorSubCategory.fromJS(_data["vendorSubCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserVendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new UserVendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["vendorSubCategoryId"] = this.vendorSubCategoryId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["vendorSubCategory"] = this.vendorSubCategory ? this.vendorSubCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserVendorSubCategory {
        const json = this.toJSON();
        let result = new UserVendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IUserVendorSubCategory {
    userId: string | undefined;
    vendorSubCategoryId: number;
    user: ApplicationUser;
    vendorSubCategory: VendorSubCategory;
}

export class Varient implements IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number | undefined;
    size: Size;
    colorId: number | undefined;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;

    constructor(data?: IVarient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.sizeId = _data["sizeId"];
            this.size = _data["size"] ? Size.fromJS(_data["size"]) : <any>undefined;
            this.colorId = _data["colorId"];
            this.color = _data["color"] ? Color.fromJS(_data["color"]) : <any>undefined;
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.mainImagePath = _data["mainImagePath"];
            this.mrpPrice = _data["mrpPrice"];
            this.discount = _data["discount"];
            this.price = _data["price"];
            this.quanity = _data["quanity"];
            this.minQuanity = _data["minQuanity"];
            this.maxQuanity = _data["maxQuanity"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["varientImage"])) {
                this.varientImage = [] as any;
                for (let item of _data["varientImage"])
                    this.varientImage.push(VarientImage.fromJS(item));
            }
            if (Array.isArray(_data["userCart"])) {
                this.userCart = [] as any;
                for (let item of _data["userCart"])
                    this.userCart.push(UserCart.fromJS(item));
            }
            if (Array.isArray(_data["orderDetail"])) {
                this.orderDetail = [] as any;
                for (let item of _data["orderDetail"])
                    this.orderDetail.push(OrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Varient {
        data = typeof data === 'object' ? data : {};
        let result = new Varient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["sizeId"] = this.sizeId;
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        data["colorId"] = this.colorId;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["mainImagePath"] = this.mainImagePath;
        data["mrpPrice"] = this.mrpPrice;
        data["discount"] = this.discount;
        data["price"] = this.price;
        data["quanity"] = this.quanity;
        data["minQuanity"] = this.minQuanity;
        data["maxQuanity"] = this.maxQuanity;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.varientImage)) {
            data["varientImage"] = [];
            for (let item of this.varientImage)
                data["varientImage"].push(item.toJSON());
        }
        if (Array.isArray(this.userCart)) {
            data["userCart"] = [];
            for (let item of this.userCart)
                data["userCart"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetail)) {
            data["orderDetail"] = [];
            for (let item of this.orderDetail)
                data["orderDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): Varient {
        const json = this.toJSON();
        let result = new Varient();
        result.init(json);
        return result;
    }
}

export interface IVarient {
    id: number;
    tid: number;
    productId: number;
    product: Product;
    sizeId: number | undefined;
    size: Size;
    colorId: number | undefined;
    color: Color;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    mainImagePath: string | undefined;
    mrpPrice: number;
    discount: number;
    price: number;
    quanity: number;
    minQuanity: number;
    maxQuanity: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    varientImage: VarientImage[] | undefined;
    userCart: UserCart[] | undefined;
    orderDetail: OrderDetail[] | undefined;
}

export class VarientImage implements IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVarientImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.varientId = _data["varientId"];
            this.varient = _data["varient"] ? Varient.fromJS(_data["varient"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VarientImage {
        data = typeof data === 'object' ? data : {};
        let result = new VarientImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["varientId"] = this.varientId;
        data["varient"] = this.varient ? this.varient.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VarientImage {
        const json = this.toJSON();
        let result = new VarientImage();
        result.init(json);
        return result;
    }
}

export interface IVarientImage {
    id: number;
    tid: number;
    varientId: number;
    varient: Varient;
    imagePath: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class VendorCategory implements IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;

    constructor(data?: IVendorCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.imagePath = _data["imagePath"];
            this.name = _data["name"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["vendorSubCategory"])) {
                this.vendorSubCategory = [] as any;
                for (let item of _data["vendorSubCategory"])
                    this.vendorSubCategory.push(VendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["imagePath"] = this.imagePath;
        data["name"] = this.name;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.vendorSubCategory)) {
            data["vendorSubCategory"] = [];
            for (let item of this.vendorSubCategory)
                data["vendorSubCategory"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorCategory {
        const json = this.toJSON();
        let result = new VendorCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorCategory {
    id: number;
    tid: number;
    imagePath: string | undefined;
    name: string;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    vendorSubCategory: VendorSubCategory[] | undefined;
}

export class VendorCover implements IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;

    constructor(data?: IVendorCover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.applicatioUserId = _data["applicatioUserId"];
            this.applicatioUser = _data["applicatioUser"] ? ApplicationUser.fromJS(_data["applicatioUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorCover {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCover();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["applicatioUserId"] = this.applicatioUserId;
        data["applicatioUser"] = this.applicatioUser ? this.applicatioUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): VendorCover {
        const json = this.toJSON();
        let result = new VendorCover();
        result.init(json);
        return result;
    }
}

export interface IVendorCover {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicatioUserId: string | undefined;
    applicatioUser: ApplicationUser;
}

export class VendorCoversResponseModel implements IVendorCoversResponseModel {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicationUserId: string | undefined;

    constructor(data?: IVendorCoversResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.applicationUserId = _data["applicationUserId"];
        }
    }

    static fromJS(data: any): VendorCoversResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCoversResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["applicationUserId"] = this.applicationUserId;
        return data;
    }

    clone(): VendorCoversResponseModel {
        const json = this.toJSON();
        let result = new VendorCoversResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorCoversResponseModel {
    id: number;
    tid: number;
    name: string | undefined;
    imagePath: string | undefined;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    applicationUserId: string | undefined;
}

export class VendorSubCategory implements IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;

    constructor(data?: IVendorSubCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.vendorCategory = _data["vendorCategory"] ? VendorCategory.fromJS(_data["vendorCategory"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["userSubCategories"])) {
                this.userSubCategories = [] as any;
                for (let item of _data["userSubCategories"])
                    this.userSubCategories.push(UserVendorSubCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSubCategory {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["vendorCategory"] = this.vendorCategory ? this.vendorCategory.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.userSubCategories)) {
            data["userSubCategories"] = [];
            for (let item of this.userSubCategories)
                data["userSubCategories"].push(item.toJSON());
        }
        return data;
    }

    clone(): VendorSubCategory {
        const json = this.toJSON();
        let result = new VendorSubCategory();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategory {
    id: number;
    tid: number;
    vendorCategoryId: number;
    vendorCategory: VendorCategory;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
    userSubCategories: UserVendorSubCategory[] | undefined;
}

export class VendorSubCategoryResponseModel implements IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;

    constructor(data?: IVendorSubCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorCategoryId = _data["vendorCategoryId"];
            this.imagePath = _data["imagePath"];
            this.metaKeyword = _data["metaKeyword"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): VendorSubCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorCategoryId"] = this.vendorCategoryId;
        data["imagePath"] = this.imagePath;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["status"] = this.status;
        return data;
    }

    clone(): VendorSubCategoryResponseModel {
        const json = this.toJSON();
        let result = new VendorSubCategoryResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorSubCategoryResponseModel {
    id: number;
    tid: number;
    vendorCategoryId: number;
    imagePath: string | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    name: string | undefined;
    status: boolean;
}

export class VendorWishlist implements IVendorWishlist {
    id: number;
    tid: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVendorWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.vendorId = _data["vendorId"];
            this.vendor = _data["vendor"] ? ApplicationUser.fromJS(_data["vendor"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VendorWishlist {
        data = typeof data === 'object' ? data : {};
        let result = new VendorWishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["vendorId"] = this.vendorId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VendorWishlist {
        const json = this.toJSON();
        let result = new VendorWishlist();
        result.init(json);
        return result;
    }
}

export interface IVendorWishlist {
    id: number;
    tid: number;
    vendorId: string | undefined;
    vendor: ApplicationUser;
    userId: string | undefined;
    user: ApplicationUser;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class VendorWishListResponseModel implements IVendorWishListResponseModel {
    id: number;
    vendorId: string | undefined;
    userId: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IVendorWishListResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorId = _data["vendorId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): VendorWishListResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorWishListResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorId"] = this.vendorId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): VendorWishListResponseModel {
        const json = this.toJSON();
        let result = new VendorWishListResponseModel();
        result.init(json);
        return result;
    }
}

export interface IVendorWishListResponseModel {
    id: number;
    vendorId: string | undefined;
    userId: string | undefined;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class Wishlist implements IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): Wishlist {
        data = typeof data === 'object' ? data : {};
        let result = new Wishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): Wishlist {
        const json = this.toJSON();
        let result = new Wishlist();
        result.init(json);
        return result;
    }
}

export interface IWishlist {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    product: Product;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export class WishListModel implements IWishListModel {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;

    constructor(data?: IWishListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tid = _data["tid"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? moment(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedDate = _data["updatedDate"] ? moment(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): WishListModel {
        data = typeof data === 'object' ? data : {};
        let result = new WishListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tid"] = this.tid;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        return data;
    }

    clone(): WishListModel {
        const json = this.toJSON();
        let result = new WishListModel();
        result.init(json);
        return result;
    }
}

export interface IWishListModel {
    id: number;
    tid: number;
    userId: string | undefined;
    productId: number;
    status: boolean;
    createdDate: moment.Moment;
    createdBy: string | undefined;
    updatedDate: moment.Moment;
    updatedBy: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}